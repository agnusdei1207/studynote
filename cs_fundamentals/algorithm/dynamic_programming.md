# 동적 계획법 (Dynamic Programming, DP) 알고리즘

## I. 중복 부분 문제를 기억하여 효율성을 극대화하는 동적 계획법(Dynamic Programming)의 개념

### 1.1 정의
- 복잡한 문제를 **중복되는 부분 문제(Overlapping Sub-problems)**로 분할한 뒤, 한 번 계산한 결과를 **메모리에 저장(Memoization 또는 Tabulation)**하여 동일한 부분 문제가 재등장할 때 재계산 없이 결과를 재사용하는 최적화 기법입니다.
- **최적 부분 구조(Optimal Substructure)**: 문제의 최적해가 그 부분 문제들의 최적해로 구성될 수 있어야 적용이 가능합니다.

### 1.2 등장 배경
- **지수적 중복 연산의 제거:** 분할 정복(Divide and Conquer) 방식에서 발생하는 동일 부분 문제의 반복 계산(예: 피보나치 수열 $O(2^n)$)을 $O(n)$으로 획기적으로 개선하기 위해 등장하였습니다.
- **최적화 문제 해결:** 단순 탐색으로는 조합 폭발(Combinatorial Explosion)이 발생하는 경로 탐색, 자원 배분 등 최적화 문제에서 실용적인 해법을 제공합니다.
- **벨만(Richard Bellman)의 공헌:** 1950년대 벨만이 다단계 의사결정 과정을 수학적으로 정립하며 'Dynamic Programming'이라는 용어를 창안하였습니다.

---

## II. 동적 계획법의 코어 구성요소 및 핵심 원리

### 2.1 적용을 위한 2대 필수 조건
| 조건 | 항목 | 설명 |
| :--- | :--- | :--- |
| **조건 1** | **중복 부분 문제 (Overlapping Sub-problems)** | 동일한 부분 문제가 여러 번 반복 호출되어야 함. 재계산 비용을 절감할 수 있는 근거. |
| **조건 2** | **최적 부분 구조 (Optimal Substructure)** | 전체 문제의 최적해가 부분 문제의 최적해를 포함하고 있어야 함. (예: 최단 경로 문제) |

### 2.2 2대 구현 방식 비교
| 구분 | 메모이제이션 (Memoization) | 타뷸레이션 (Tabulation) |
| :--- | :--- | :--- |
| **접근 방향** | 하향식 (Top-Down) | 상향식 (Bottom-Up) |
| **구현 방법** | 재귀 함수 + 캐시(Cache) 배열/맵 | 반복문 + DP 테이블 |
| **호출 방식** | 필요할 때만 계산 (Lazy Evaluation) | 모든 부분 문제를 순차적으로 계산 |
| **스택 사용** | 재귀 호출로 인한 호출 스택 사용 (Stack Overflow 위험) | 반복문 사용으로 스택 부담 없음 |
| **사용 예시** | 피보나치 수열, 깊이 우선 탐색(Depth-First Search, DFS) 기반 DP | 배낭 문제, LCS, 최단 경로 |

### 2.3 핵심 메커니즘: 점화식(Recurrence Relation)
- DP의 핵심은 **점화식(상태 전이 방정식)**을 도출하는 것입니다.
- 예시: 피보나치 수열 $F(n) = F(n-1) + F(n-2)$, 단 $F(0) = 0, F(1) = 1$
- 점화식은 현재 상태의 값을 이전 상태의 값들로 표현하며, 이를 통해 반복적으로 문제를 해결해 나갑니다.

```
[일반적인 DP 알고리즘 흐름]
1. 문제를 상태(State)로 정의
2. 상태 간의 관계를 점화식으로 표현
3. 기저 사례(Base Case) 설정
4. 메모이제이션 또는 타뷸레이션으로 구현
5. 최종 답 도출
```

---

## III. 주요 알고리즘 사례 분석 및 비교

### 3.1 대표적 활용 사례
| 알고리즘 | 설명 | 시간 복잡도 ($T(n)$) |
| :--- | :--- | :--- |
| **피보나치 수열 (Fibonacci)** | DP 적용 시 중복 계산을 제거하고 선형 시간에 해결 | $O(n)$ |
| **최장 공통 부분 수열 (Longest Common Subsequence, LCS)** | 두 문자열 간 가장 긴 공통 부분 수열을 찾는 문제 | $O(m \times n)$ |
| **0/1 배낭 문제 (0/1 Knapsack)** | 제한된 용량에서 최대 가치를 얻도록 물건 선택 | $O(n \times W)$ |
| **최단 경로 (Bellman-Ford, Floyd-Warshall)** | 그래프에서 음수 가중치를 포함한 최단 경로 탐색 | $O(VE)$, $O(V^3)$ |
| **편집 거리 (Edit Distance, Levenshtein)** | 문자열 A를 B로 변환하는 최소 연산 횟수 계산 | $O(m \times n)$ |
| **행렬 연쇄 곱셈 (Matrix Chain Multiplication)** | 행렬 곱셈 연산 횟수를 최소화하는 순서 결정 | $O(n^3)$ |

### 3.2 분할 정복 vs 동적 계획법 비교
| 구분 | 분할 정복 (Divide and Conquer) | 동적 계획법 (Dynamic Programming) |
| :--- | :--- | :--- |
| **부분 문제 특성** | 독립적 (Independent) | 중복적 (Overlapping) |
| **접근 방식** | 하향식 (Top-Down Only) | 하향식/상향식 모두 가능 |
| **결과 재사용** | 없음 | 있음 (Memoization/Tabulation) |
| **대표 사례** | 병합 정렬, 퀵 정렬 | 피보나치, LCS, 배낭 문제 |
| **적합한 문제** | 소문제가 겹치지 않는 경우 | 소문제가 반복 등장하는 경우 |

---

## IV. 기술사적 판단 및 미래 전망

### 4.1 기술사적 판단 (Professional Engineer, PE's Insight)
- **공간-시간 트레이드오프(Space-Time Trade-off):** DP는 시간 복잡도를 극적으로 낮추는 대신 추가적인 메모리 공간을 사용합니다. 공간 복잡도 최적화를 위해 **1차원 배열 롤링(Rolling Array)** 기법 등이 활용됩니다.
- **상태 정의의 중요성:** 문제 해결의 핵심은 **상태(State)를 어떻게 정의하고 점화식을 어떻게 도출하느냐**에 달려 있습니다. 상태 설계 역량이 DP 활용 능력을 좌우합니다.
- **NP-Hard 문제와의 관계:** 모든 최적화 문제에 DP가 적용 가능한 것은 아닙니다. 최적 부분 구조가 성립하지 않거나 상태 공간이 지수적으로 폭발하는 경우 근사 알고리즘이나 휴리스틱(Heuristic)을 병행해야 합니다.
- **그리디(Greedy)와의 선택:** 최적 부분 구조가 있고 탐욕적 선택 속성(Greedy Choice Property)까지 만족하면 DP보다 단순한 그리디 알고리즘이 더 효율적입니다.

### 4.2 미래 전망 및 발전 방향
- **강화학습(Reinforcement Learning, RL)과의 융합:** 벨만 방정식(Bellman Equation)은 현대 강화학습의 이론적 근간입니다. Q-Learning, Policy Gradient 등 AI 분야에서 DP 개념이 확장 적용되고 있습니다.
- **대규모 분산 DP:** 빅데이터 환경에서 상태 공간이 메모리 한계를 초과할 경우, 분산 컴퓨팅 프레임워크와 결합하여 병렬 DP를 구현하는 연구가 활발합니다.
- **근사 DP (Approximate Dynamic Programming):** 상태 공간이 연속적이거나 매우 큰 경우, 함수 근사(Function Approximation)를 적용하여 실용적 해법을 도출하는 기법이 발전하고 있습니다.

---

## [부록] 쉽게 이해하는 동적 계획법 (똑똑한 일기장 전략)

**어린이 친구들, 안녕하세요! 오늘은 '동적 계획법'이라는 똑똑한 전략을 알려줄게요.**

### 📓 비유: "수학 숙제와 똑똑한 일기장"
여러분이 구구단 숙제를 하는데, 선생님이 "7 × 8 = ?" 문제를 열 번이나 물어본다고 생각해보세요.

**방법 1 (멍청한 방법):** 매번 7을 8번 더해요. 7+7+7+7+7+7+7+7... 너무 힘들어요! 😵

**방법 2 (똑똑한 방법 = 동적 계획법!):**
1.  **처음 한 번만 열심히 계산해요.** "7 × 8 = 56!"
2.  **일기장에 메모해요.** 📝 "7 × 8 = 56"
3.  **나중에 또 물어보면?** 일기장을 슥 보고 바로 "56!"이라고 대답해요! ✨

### 🌟 핵심 포인트
- **"한 번 푼 문제는 기억해두고, 다시 물어보면 바로 대답한다!"**
- 이것이 바로 **메모이제이션(Memoization)**이에요. '메모'하고 비슷하죠?
- 복잡한 퍼즐도 작은 조각 답을 차근차근 기록해두면, 마지막에 큰 퍼즐을 쉽게 완성할 수 있어요!

### 🧩 실생활 예시: 계단 오르기
- 10층까지 가는 방법을 알고 싶을 때
- 1층, 2층, 3층... 가는 방법을 차례로 메모해두면
- 10층 가는 방법은 9층, 8층 방법을 합치면 바로 알 수 있어요!

**기억하세요: "풀었으면 적어두자! 똑같은 문제를 두 번 풀 필요 없어!"** 🎉
