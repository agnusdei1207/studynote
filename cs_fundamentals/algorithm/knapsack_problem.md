# 배낭 문제 (Knapsack Problem)

## I. 제한된 용량에서 최대 가치를 추구하는 배낭 문제(Knapsack Problem)의 개념

### 1.1 정의
- **배낭 문제(Knapsack Problem)**는 제한된 용량(Capacity)을 가진 배낭에 여러 물건을 담을 때, 담을 수 있는 물건들의 **가치(Value) 합계를 최대화**하는 조합 최적화(Combinatorial Optimization) 문제입니다.
- 각 물건은 고유한 **무게(Weight)**와 **가치(Value)**를 가지며, 배낭의 용량 제한을 초과하지 않으면서 최적의 선택을 찾아야 합니다.

### 1.2 등장 배경
- **자원 배분 문제의 수학적 모델링:** 1897년 수학자 조지 던치히(George Dantzig)에 의해 처음 형식화되었으며, 제한된 자원 하에서 최적의 의사결정을 내리는 현실 문제를 추상화한 것입니다.
- **NP-완전(NP-Complete) 문제의 대표:** 암호학, 자원 스케줄링, 금융 포트폴리오 최적화 등 다양한 분야의 기초 모델로 활용되며, 계산 복잡도 이론의 핵심 연구 대상입니다.
- **동적 계획법(Dynamic Programming, DP)의 대표적 응용:** DP의 원리와 구현 방법을 학습하기 위한 교과서적 예제로 널리 사용됩니다.

---

## II. 배낭 문제의 유형 분류 및 핵심 구성요소

### 2.1 배낭 문제의 주요 유형
| 유형 | 항목 | 설명 |
| :--- | :--- | :--- |
| **Type 1** | **0/1 배낭 문제 (0/1 Knapsack Problem)** | 각 물건을 **선택(1)하거나 선택하지 않음(0)**. 분할 불가. DP로 해결. |
| **Type 2** | **분할 가능 배낭 문제 (Fractional Knapsack Problem)** | 물건을 **분할하여 일부만** 담을 수 있음. 탐욕 알고리즘(Greedy Algorithm)으로 해결. |
| **Type 3** | **무한 배낭 문제 (Unbounded Knapsack Problem)** | 각 물건을 **무한 개** 담을 수 있음. DP로 해결. |
| **Type 4** | **다중 배낭 문제 (Multiple Knapsack Problem)** | **여러 개의 배낭**에 물건을 최적 분배. 확장된 DP 또는 메타휴리스틱(Metaheuristic) 적용. |

### 2.2 문제 정의의 핵심 요소
| 구성 요소 | 기호 | 설명 |
| :--- | :--- | :--- |
| **물건 집합** | $\{1, 2, ..., n\}$ | 선택 가능한 n개의 물건 |
| **무게** | $w_i$ | i번째 물건의 무게 |
| **가치** | $v_i$ | i번째 물건의 가치 |
| **배낭 용량** | $W$ | 배낭이 담을 수 있는 최대 무게 |
| **선택 변수** | $x_i$ | i번째 물건의 선택 여부 (0 또는 1, 분할 시 0~1 사이) |

### 2.3 수학적 정식화 (0/1 Knapsack)
```
목적 함수 (Objective Function):
    Maximize  Σ(v_i × x_i)  (i = 1 to n)

제약 조건 (Constraint):
    Σ(w_i × x_i) ≤ W  (i = 1 to n)
    x_i ∈ {0, 1}
```

---

## III. 0/1 배낭 문제의 동적 계획법 해법

### 3.1 점화식 (Recurrence Relation)
- DP 테이블 $dp[i][w]$: 처음 i개의 물건을 고려했을 때, 용량 w 이하에서 얻을 수 있는 최대 가치

$$
dp[i][w] = \begin{cases}
dp[i-1][w] & \text{if } w_i > w \text{ (물건 i를 담을 수 없음)} \\
\max(dp[i-1][w], \; dp[i-1][w-w_i] + v_i) & \text{if } w_i \leq w \text{ (담거나 안 담거나)}
\end{cases}
$$

### 3.2 기저 사례 (Base Case)
- $dp[0][w] = 0$ (물건이 없으면 가치도 0)
- $dp[i][0] = 0$ (용량이 0이면 아무것도 못 담음)

### 3.3 알고리즘 의사 코드 (Pseudocode)
```
function knapsack(n, W, weights[], values[]):
    // DP 테이블 초기화
    dp[0...n][0...W] = 0
    
    for i = 1 to n:
        for w = 1 to W:
            if weights[i] > w:
                dp[i][w] = dp[i-1][w]          // 안 담음
            else:
                dp[i][w] = max(
                    dp[i-1][w],                 // 안 담음
                    dp[i-1][w - weights[i]] + values[i]  // 담음
                )
    
    return dp[n][W]  // 최대 가치
```

### 3.4 시간 및 공간 복잡도
| 구분 | 복잡도 | 설명 |
| :--- | :--- | :--- |
| **시간 복잡도** | $O(n \times W)$ | 물건 수(n)와 배낭 용량(W)의 곱 |
| **공간 복잡도** | $O(n \times W)$ | 2차원 DP 테이블 사용 시 |
| **공간 최적화** | $O(W)$ | 1차원 롤링 배열(Rolling Array) 적용 시 |

---

## IV. 분할 가능 배낭 문제의 탐욕 알고리즘 해법

### 4.1 핵심 원리
- 물건을 **단위 무게당 가치(Value per Unit Weight)** 기준으로 내림차순 정렬
- 가치 밀도가 높은 물건부터 최대한 담고, 용량이 부족하면 **일부만 분할**하여 담음

### 4.2 알고리즘 흐름
```
1. 각 물건의 가치 밀도 계산: density[i] = v[i] / w[i]
2. 가치 밀도 기준 내림차순 정렬
3. 용량이 남아있는 동안:
   - 현재 물건 전체를 담을 수 있으면 전체 담기
   - 아니면 남은 용량만큼만 분할하여 담기
4. 총 가치 반환
```

### 4.3 시간 복잡도
- **정렬:** $O(n \log n)$
- **탐욕 선택:** $O(n)$
- **총 시간 복잡도:** $O(n \log n)$

---

## V. 유형별 해법 비교 및 기술사적 판단

### 5.1 유형별 해법 비교
| 유형 | 최적 해법 | 시간 복잡도 | 최적해 보장 |
| :--- | :--- | :--- | :--- |
| **0/1 배낭** | 동적 계획법(Dynamic Programming, DP) | $O(n \times W)$ | ✅ 예 |
| **분할 가능 배낭** | 탐욕 알고리즘(Greedy Algorithm) | $O(n \log n)$ | ✅ 예 |
| **무한 배낭** | 동적 계획법(Dynamic Programming, DP) | $O(n \times W)$ | ✅ 예 |
| **다중 배낭** | 분기 한정법(Branch and Bound), 메타휴리스틱(Metaheuristic) | 지수적 | 근사 가능 |

### 5.2 기술사적 판단 (PE's Insight)
- **의사 다항 시간(Pseudo-Polynomial Time):** 0/1 배낭 문제의 $O(n \times W)$는 입력 크기가 아닌 **입력 값(W)**에 비례합니다. W가 매우 클 경우 실질적으로 지수 시간에 가까워지므로, NP-완전(NP-Complete) 문제로 분류됩니다.
- **그리디 vs DP 선택 기준:** 물건 분할이 가능하면 그리디가 최적, 불가능하면 DP가 필수입니다. **탐욕적 선택 속성(Greedy Choice Property)**의 성립 여부가 핵심 판단 기준입니다.
- **공간 최적화 필수:** 실무에서 W가 클 경우 2차원 테이블 대신 **1차원 롤링 배열**을 사용하여 메모리 사용량을 $O(n \times W)$에서 $O(W)$로 감소시켜야 합니다.
- **역추적(Backtracking) 구현:** 최대 가치뿐 아니라 **어떤 물건을 선택했는지** 알아야 할 경우, DP 테이블을 역으로 추적하는 로직이 추가로 필요합니다.

### 5.3 미래 전망 및 발전 방향
- **조합 최적화와 인공지능(Artificial Intelligence, AI):** 강화학습(Reinforcement Learning, RL), 유전 알고리즘(Genetic Algorithm, GA) 등 메타휴리스틱 기법과 결합하여 대규모 배낭 문제의 근사 최적해를 빠르게 도출하는 연구가 활발합니다.
- **클라우드 자원 할당:** 클라우드 컴퓨팅 환경에서 가상 머신(Virtual Machine, VM) 배치, 컨테이너 스케줄링 등 자원 최적화 문제에 배낭 문제 모델이 직접 적용됩니다.
- **금융 및 물류:** 포트폴리오 최적화, 화물 적재 최적화, 예산 배분 등 현실 비즈니스 문제 해결에 핵심 모델로 활용됩니다.

---

## [부록] 쉽게 이해하는 배낭 문제 (보물 사냥꾼의 고민)

**어린이 친구들, 안녕하세요! 오늘은 '배낭 문제'라는 재미있는 퍼즐을 알려줄게요.**

### 🎒 비유: "보물 동굴 탈출 작전"
여러분이 보물 동굴에서 보물을 발견했어요! 하지만 배낭은 딱 10kg만 담을 수 있어요.

| 보물 | 무게 | 가치 |
| :--- | :--- | :--- |
| 💎 다이아몬드 | 2kg | 100만원 |
| 🏆 금 트로피 | 5kg | 80만원 |
| 👑 왕관 | 4kg | 70만원 |
| 📿 목걸이 | 3kg | 50만원 |

**문제:** 10kg 배낭에 어떤 보물을 담아야 가장 부자가 될까요?

### 🧠 해결 방법 (동적 계획법)
1.  **작은 배낭부터 생각해요:** 1kg 배낭, 2kg 배낭, 3kg 배낭... 차근차근!
2.  **각 보물마다 선택해요:** "이 보물을 담을까? 말까?"
3.  **표에 기록해요:** 각 상황에서 최대로 얻을 수 있는 가치를 적어요.
4.  **마지막에 정답 확인!** 10kg 배낭의 최대 가치가 답이에요!

### 💡 정답
- **다이아몬드(2kg) + 왕관(4kg) + 목걸이(3kg) = 9kg, 220만원!** 🎉
- 금 트로피를 담으면 (5kg + 2kg + 3kg = 10kg, 230만원) 더 좋아요!

### 🌟 핵심 포인트
- **"무거운 게 항상 좋은 건 아니에요!"**
- 가치와 무게를 똑똑하게 비교해서 최고의 조합을 찾는 것이 배낭 문제의 핵심이에요.
- 실생활에서도 여행 갈 때 캐리어에 뭘 넣을지, 용돈으로 뭘 살지 고민할 때 이 방법이 도움이 된답니다! 🧳
