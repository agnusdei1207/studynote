# 분할 정복 (Divide and Conquer) 알고리즘

## 1. 개요 (Overview)

**분할 정복(Divide and Conquer)**은 복잡하고 큰 문제를 **더 작고 관리하기 쉬운 하위 문제(Sub-problems)로 나누어(Divide)** 각각 해결한 뒤, 그 결과들을 **결합(Combine)**하여 원래의 문제를 해결하는 알고리즘 설계 패러다임입니다.

이 방식은 현대 컴퓨터 과학에서 가장 중요하고 널리 사용되는 기법 중 하나이며, 특히 **병합 정렬(Merge Sort)**, **퀵 정렬(Quick Sort)**, **고속 푸리에 변환(FFT)** 등에서 핵심적으로 사용됩니다.

## 2. 작동 원리 (3단계)

분할 정복은 일반적으로 다음 3단계 과정을 거칩니다.

1.  **분할 (Divide)**:
    - 현재의 문제(Problem)를 동일하거나 유사한 형태의 더 작은 하위 문제(Sub-problems)들로 나눕니다.
    - 예를 들어, 배열을 반으로 쪼개는 행위가 여기에 해당합니다.

2.  **정복 (Conquer)**:
    - 나누어진 하위 문제들을 재귀적(Recursive)으로 해결합니다.
    - **기저 조건(Base Case)**: 하위 문제의 규모가 충분히 작아지면(예: 리스트의 원소가 1개이거나 0개), 더 이상 나누지 않고 직접 해를 구합니다.

3.  **결합 (Combine)**:
    - 하위 문제들에서 구한 해(Solution)들을 적절히 병합하여 원래 문제의 해답을 구성합니다.
    - (문제에 따라 이 단계가 필요 없는 경우도 있습니다. 예: 이진 탐색은 해를 찾으면 종료하므로 결합 과정이 단순하거나 없음)

## 3. 직관적인 비유 (Analogy)

**"거대한 도서관의 책 정리하기"**

도서관에 마구잡이로 쌓인 10,000권의 책을 제목 순으로 정렬해야 한다고 가정해 봅시다.
- 혼자서 10,000권을 한 번에 정리하려면 매우 복잡하고 시간이 오래 걸립니다. (O(N^2) 삽입 정렬 방식 등)
- **분할 정복 접근**:
    1.  **분할**: 책 더미를 5,000권씩 두 그룹으로 나눕니다. 다시 2,500권, 1,250권... 결국 1권이 될 때까지 계속 나눕니다.
    2.  **정복**: 1권짜리 더미는 이미 정렬된 상태입니다(기저 조건). 이제 1권짜리 두 개를 비교하여 2권짜리 정렬된 더미를 만듭니다.
    3.  **결합**: 정렬된 작은 더미들을 합쳐서 더 큰 정렬된 더미를 만듭니다. 최종적으로 10,000권이 모두 정렬됩니다.

## 4. 대표적인 예시: 병합 정렬 (Merge Sort)

병합 정렬은 분할 정복의 가장 교과서적인 예시입니다.

- **Divide**: 리스트를 중간 지점에서 두 개의 리스트로 분할합니다.
- **Conquer**: 각 부분 리스트를 재귀적으로 병합 정렬합니다. (리스트 크기가 1이면 종료)
- **Combine**: 정렬된 두 부분 리스트를 하나의 정렬된 리스트로 병합(Merge)합니다.

이 과정 덕분에 시간 복잡도는 일반적인 $O(N^2)$에서 **$O(N \log N)$**으로 획기적으로 줄어듭니다.

## 5. 장점과 단점

### 장점
- **효율성**: $O(N^2)$이 소요될 문제를 $O(N \log N)$ 등으로 획기적으로 단축할 수 있습니다.
- **병렬성 (Parallelism)**: 하위 문제들이 서로 독립적이므로, 멀티 코어 프로세서에서 동시에(병렬로) 실행하기 매우 유리합니다.
- **메모리 캐시 효율**: 데이터의 지역성(Locality)이 좋아 캐시 적중률을 높일 수 있는 경우가 많습니다.

### 단점
- **재귀 호출 오버헤드**: 함수 호출이 깊어지면 스택 메모리를 많이 사용하고, 호출 자체의 오버헤드가 발생할 수 있습니다 (Stack Overflow 위험).
- **복잡한 구현**: 단순히 반복문(Loop)을 쓰는 것보다 개념적으로 어렵고 구현이 복잡할 수 있습니다.

## 6. Rust 코드 예시 (Merge Sort)

```rust
fn merge_sort(arr: &mut [i32]) {
    let len = arr.len();
    if len <= 1 {
        return; // 기저 조건 (Conquer)
    }

    let mid = len / 2;
    
    // 분할 (Divide)
    // 실제 Rust 구현에서는 slice를 안전하게 나누기 위해 split_at_mut 등을 활용하거나,
    // 보조 벡터를 통해 병합 과정을 수행하는 것이 일반적입니다.
    // 여기서는 개념적인 이해를 돕기 위해 벡터를 복제(clone)하여 나눕니다.
    
    let mut left = arr[0..mid].to_vec();
    let mut right = arr[mid..].to_vec();

    merge_sort(&mut left);
    merge_sort(&mut right);

    // 결합 (Combine)
    merge(arr, &left, &right);
}

fn merge(arr: &mut [i32], left: &[i32], right: &[i32]) {
    let (mut i, mut j, mut k) = (0, 0, 0);
    
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            arr[k] = left[i];
            i += 1;
        } else {
            arr[k] = right[j];
            j += 1;
        }
        k += 1;
    }

    // 남은 요소들 추가
    while i < left.len() {
        arr[k] = left[i];
        i += 1;
        k += 1;
    }
    while j < right.len() {
        arr[k] = right[j];
        j += 1;
        k += 1;
    }
}
```
