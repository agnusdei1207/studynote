# 탐욕 알고리즘 (Greedy Algorithm)

## 1. 개요 및 정의
탐욕 알고리즘(Greedy Algorithm)은 문제 해결 과정에서 매 순간마다 **최적이라고 생각되는 선택(Local Optimal Choice)**을 해나가며, 최종적인 해답에 도달하는 알고리즘 설계 기법이다. 전체적인 시야에서 최적의 해를 구하는 것이 아니라, 현재 상태에서의 최선의 선택이 결과적으로 전체 최적해(Global Optimum)가 되기를 기대하며 수행된다.

## 2. 등장 배경 및 필요성
1.  **계산 복잡도 최적화**: 동적 계획법(Dynamic Programming, DP)이나 전수 조사(Brute Force)는 정확한 해를 보장하지만, 자원 소모와 시간이 많이 소요된다. 그리디 알고리즘은 이를 효율적으로 해결하기 위해 고안되었다.
2.  **근사해(Approximation) 요구**: 모든 문제의 최적해를 찾는 것이 다항 시간 내에 해결 불가능한 **결정론적 다항시간 난제(Non-deterministic Polynomial-time Hard, NP-Hard)**와 같이 매우 어려운 경우, 실용적인 시간 내에 충분히 좋은 해를 구하기 위해 사용된다.

## 3. 핵심 성립 조건 및 구성 요소
그리디 알고리즘이 최적해를 보장하기 위해 반드시 만족해야 하는 두 가지 조건이 존재한다.

### 3.1 2가지 핵심 조건
| 조건 | 상세 설명 |
| :--- | :--- |
| **탐욕적 선택 속성 (Greedy Choice Property)** | 매 순간의 선택이 이후의 선택에 영향을 주지 않으며, 부분적인 최적 선택이 결국 전체 최적해로 이어진다는 속성. |
| **최적 부분 구조 (Optimal Substructure)** | 문제의 최적해 내에 부분 문제의 최적해가 포함되어 있는 구조. |

### 3.2 알고리즘 수행 단계
```text
[단계 1: 선택 (Selection)] -> 현재 상태에서 가장 이익이 큰 대안을 선택
           |
[단계 2: 적합성 검사 (Feasibility Check)] -> 선택된 대안이 문제의 제약 조건을 위반하지 않는지 확인
           |
[단계 3: 해답 검사 (Solution Check)] -> 전체 문제가 해결되었는지 확인 (미완료 시 다시 1단계로)
```

## 4. 동적 계획법(DP)과의 비교

| 구분 | 탐욕 알고리즘 (Greedy) | 동적 계획법 (DP) |
| :--- | :--- | :--- |
| **선택 방식** | 매 단계 최적의 선택을 수행 (Top-Down 방식 위주) | 모든 하위 문제의 결과를 고려 (Bottom-Up 방식 위주) |
| **최적해 보장** | 보장되지 않을 수 있음 (근사해 성격) | 항상 최적해 보장 |
| **효율성** | 시간 및 공간 복잡도가 낮음 | 상대적으로 복잡도가 높음 |
| **적용 사례** | 최소 신장 트리(Minimum Spanning Tree, MST), 허프만 코딩(Huffman Coding) | 최단 경로(All-Pairs), 배낭 문제(Knapsack 0/1) |

## 5. 주요 알고리즘 사례
1.  **Dijkstra(데이크스트라) 알고리즘**: 가중치가 양수인 그래프에서 단일 출발점 최단 경로 탐색.
2.  **Prim(프림) & Kruskal(크루스칼) 알고리즘**: 그래프 내의 모든 노드를 연결하는 **최소 신장 트리(Minimum Spanning Tree, MST)** 구성.
3.  **Huffman Coding(허프만 코딩)**: 데이터 압축을 위해 출현 빈도가 높은 문자에 짧은 비트를 부여.
4.  **Fractional Knapsack(부분 배낭 문제)**: 물건을 쪼갤 수 있는 경우, 무게 대비 가치가 높은 순으로 선택.

## 6. 기술사적 판단 (Professional Engineer Judgment)
그리디 알고리즘은 **'속도와 정확성 사이의 트레이드오프(Trade-off)'**를 관리하는 핵심 도구이다. 실제 비즈니스 환경에서는 99%의 정확도를 위해 무한한 리소스를 쓰는 것보다, 90%의 만족도를 주며 실시간 응답이 가능한 그리디 기반 시스템이 더 효율적일 수 있다. 설계 시에는 해당 문제가 그리디 속성을 만족하는지에 대한 **수학적 증명(귀류법 등)**이 선행되어야 하며, 불확실한 경우에는 휴리스틱(Heuristic) 접근법으로 분류하여 지속적인 보정 작업이 필요하다.

---

## [부록] 어린이 버전 설명 및 비유

### 🍭 초콜릿 가게에서의 선택 이야기
여러분 앞에 아주 맛있는 초콜릿들이 가득 담긴 상자가 있다고 상상해 보세요. 여러분은 딱 3개의 초콜릿만 가져갈 수 있어요.

*   **그리디 알고리즘의 방법:** "지금 내 눈앞에 보이는 초콜릿 중에 가장 크고 맛있는 것부터 일단 하나 집자!"라고 생각하고, 그 뒤에도 남은 것 중 제일 좋은 걸 계속 고르는 방식이에요.
*   **비유:** 이건 마치 산에 올라갈 때, 멀리 정상을 바라보며 길을 찾는 게 아니라 **"일단 지금 당장 내 발앞에서 가장 높은 위쪽 방향으로만 걷자!"**라고 결정하는 것과 비슷해요.

### 💡 왜 주의해야 할까요?
당장 큰 초콜릿을 골랐는데, 나중에 알고 보니 그 뒤에 숨겨져 있던 더 크고 맛있는 황금 초콜릿을 못 보게 될 수도 있어요. 그래서 그리디 알고리즘은 **"지금 당장의 선택이 나중에 후회가 되지 않을 때"**만 사용하는 아주 똑똑한(하지만 조금은 시야가 좁은) 친구랍니다!
