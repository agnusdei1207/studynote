# 위상 정렬(Topological Sorting)

## 1. 개념

**위상 정렬(Topological Sorting)**이란 **방향 비순환 그래프(Directed Acyclic Graph, DAG)**에서 **노드들의 선후 관계(의존성)**를 위배하지 않으면서 모든 노드를 **선형적으로 나열**하는 알고리즘이다.

여기서 **'위상(位相, Topology)'**이란 "누가 누구보다 먼저 와야 하는가?"라는 **상대적 순서 관계**를 의미한다.

## 2. 등장 배경

| 구분 | 설명 |
|------|------|
| **작업 스케줄링 문제** | 선행 작업이 완료되어야 후속 작업을 시작할 수 있는 의존성 관계 해결 필요 |
| **컴파일러 설계** | 소스 파일 간 의존성 분석 및 빌드 순서 결정 |
| **교과목 이수 체계** | 선수과목(Prerequisite) 시스템에서 수강 순서 도출 |
| **패키지 관리자** | 소프트웨어 패키지 간 의존성 순서대로 설치 |

## 3. 핵심 용어

| 용어 | 설명 |
|------|------|
| **방향 비순환 그래프 (DAG)** | 간선에 방향성이 있고 **순환(Cycle)이 없는** 그래프. 위상 정렬의 필수 조건 |
| **진입 차수 (In-degree)** | 특정 노드로 **들어오는** 간선의 개수 (선행 조건의 수) |
| **진출 차수 (Out-degree)** | 특정 노드에서 **나가는** 간선의 개수 (후속 작업의 수) |
| **의존성 (Dependency)** | A → B 관계에서 B는 A에 의존함 (A가 먼저 수행되어야 함) |

## 4. 핵심 원리 및 알고리즘

### 4.1 칸 알고리즘 (Kahn's Algorithm) - BFS(Breadth-First Search) 기반

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 모든 노드의 진입 차수(In-degree) 계산                         │
│  2. 진입 차수가 0인 노드를 큐(Queue)에 삽입                       │
│  3. 큐에서 노드를 꺼내 결과에 추가                                │
│  4. 해당 노드와 연결된 간선 제거 → 인접 노드의 진입 차수 감소       │
│  5. 새롭게 진입 차수가 0이 된 노드를 큐에 삽입                     │
│  6. 큐가 빌 때까지 3~5 반복                                      │
│  7. 결과 리스트의 크기 ≠ 노드 수 → 사이클 존재 (위상 정렬 불가)     │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 DFS(Depth-First Search) 기반 알고리즘

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 모든 노드에 대해 방문하지 않은 노드부터 DFS 수행               │
│  2. 재귀적으로 인접 노드 탐색                                     │
│  3. 더 이상 방문할 노드가 없으면 해당 노드를 스택(Stack)에 삽입     │
│  4. 모든 노드 탐색 완료 후 스택을 역순으로 출력                    │
└─────────────────────────────────────────────────────────────────┘
```

## 5. 시간 및 공간 복잡도

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 비고 |
|----------|-------------|-------------|------|
| **칸 알고리즘 (BFS)** | O(V + E) | O(V) | V: 정점 수, E: 간선 수 |
| **DFS 기반** | O(V + E) | O(V) | 재귀 호출 스택 고려 |

## 6. 알고리즘 비교

| 구분 | 칸 알고리즘 (BFS) | DFS 기반 |
|------|-------------------|----------|
| **탐색 방식** | 너비 우선 탐색 | 깊이 우선 탐색 |
| **자료구조** | 큐(Queue) | 스택(Stack) / 재귀 |
| **사이클 탐지** | 결과 크기로 즉시 판별 | 추가 로직 필요 (방문 상태 추적) |
| **구현 난이도** | 상대적으로 직관적 | 재귀 이해 필요 |
| **활용 추천** | 사이클 탐지가 중요한 경우 | 역순 출력이 자연스러운 경우 |

## 7. 활용 사례

| 분야 | 적용 예시 |
|------|-----------|
| **빌드 시스템** | Make, Gradle, Maven 등에서 소스 파일 컴파일 순서 결정 |
| **패키지 관리자** | npm, pip, apt 등에서 의존성 패키지 설치 순서 결정 |
| **작업 스케줄링** | 프로젝트 관리에서 작업 선후 관계에 따른 일정 수립 |
| **데이터 파이프라인** | Apache Airflow 등에서 DAG 기반 작업 흐름 관리 |
| **스프레드시트** | 셀 간 수식 의존성에 따른 계산 순서 결정 |

## 8. 장단점

| 장점 | 단점 |
|------|------|
| 의존성 관계를 명확히 해결 | **DAG에서만 적용 가능** (순환 그래프 불가) |
| O(V + E)의 효율적인 시간 복잡도 | 결과가 **유일하지 않음** (여러 정렬 결과 가능) |
| 사이클 탐지 기능 제공 | 가중치(Weight) 고려 불가 (별도 알고리즘 필요) |

## 9. 기술사적 판단

위상 정렬은 **소프트웨어 아키텍처 설계** 및 **시스템 통합** 시 다음과 같은 판단 기준을 제공한다.

1. **모듈 간 의존성 분석**: 순환 의존성(Circular Dependency) 탐지 및 제거
2. **마이크로서비스 배포 순서**: 서비스 간 의존 관계에 따른 배포 전략 수립
3. **데이터 마이그레이션**: 테이블 간 외래키(Foreign Key) 관계에 따른 마이그레이션 순서 결정

## 10. 미래 전망

| 동향 | 설명 |
|------|------|
| **분산 시스템** | 대규모 DAG 기반 워크플로우 엔진(Airflow, Prefect)의 확산 |
| **AI/ML 파이프라인** | 모델 학습 및 데이터 전처리 단계의 의존성 관리 |
| **실시간 처리** | 동적 DAG 갱신 및 증분(Incremental) 위상 정렬 연구 |
| **병렬 처리 최적화** | 독립적 작업(진입 차수 0인 노드)의 병렬 실행 전략 |

---

## 📚 부록: 쉬운 비유로 이해하기

### 🏫 대학교 수강신청

위상 정렬을 **대학교 수강신청**에 비유해 보겠습니다.

**상황:**
- `C언어 기초` → `자료구조` → `알고리즘` 순서로 들어야 합니다.
- `미적분학` → `선형대수` 순서로 들어야 합니다.
- `알고리즘`과 `선형대수`를 모두 들어야 `기계학습`을 들을 수 있습니다.

**위상 정렬이 하는 일:**
> "선수과목 규칙을 어기지 않으면서, 4년 동안 들을 수 있는 모든 과목의 순서를 한 줄로 나열해 줘!"

**결과 예시:**
```
C언어 기초 → 미적분학 → 자료구조 → 선형대수 → 알고리즘 → 기계학습
```

### 🧱 레고 조립 설명서

레고를 조립할 때 **1단계 블록을 끼워야 2단계를 할 수 있고, 2단계를 해야 3단계를 할 수 있습니다.**

위상 정렬은 이런 **"반드시 이 순서대로!"**라는 규칙을 지키면서 전체 조립 순서를 정해주는 것과 같습니다.

만약 설명서에 **"3단계를 하려면 2단계가 필요하고, 2단계를 하려면 3단계가 필요해"**라고 되어 있다면? 이건 **순환(사이클)**이 생긴 것이고, 위상 정렬은 **"이 설명서는 잘못됐어!"**라고 알려줍니다.
