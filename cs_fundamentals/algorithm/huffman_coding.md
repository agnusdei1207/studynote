# 허프만 코딩 (Huffman Coding)

## 1. 개요 및 정의
허프만 코딩(Huffman Coding)은 데이터 압축을 위해 널리 사용되는 **무손실 압축(Lossless Compression)** 알고리즘으로, 문자의 출현 빈도에 따라 가변 길이 부호(Variable-length Code)를 할당하는 방식이다. 빈도가 높은 문자에는 짧은 부호를, 빈도가 낮은 문자에는 긴 부호를 부여하여 전체 데이터의 비트 수를 최소화한다.

## 2. 등장 배경 및 필요성
1.  **데이터 전송 효율화**: 대규모 데이터를 네트워크로 전송할 때 대역폭(Bandwidth)을 절약하기 위해 데이터 크기를 줄일 필요가 있다.
2.  **가변 길이 부호의 모호성 해결**: 서로 다른 길이의 부호를 사용할 때, 한 부호가 다른 부호의 접두어(Prefix)가 되지 않게 하여 해석의 모호성을 제거하는 **접두어 속성(Prefix Property)**이 필요하게 되었다.

## 3. 핵심 원리 및 메커니즘
허프만 코딩은 **탐욕 알고리즘(Greedy Algorithm)**의 대표적인 사례로, 매 단계에서 가장 빈도가 낮은 두 노드를 합쳐 나가는 방식으로 트리를 구성한다.

### 3.1 2가지 핵심 기술 요소
| 요소 | 상세 설명 |
| :--- | :--- |
| **가변 길이 부호화 (Variable Length Coding)** | 고정 길이(예: ASCII 8비트) 대신 빈도에 따른 차등 길이를 부여함. |
| **접두어 속성 (Prefix Property)** | 어떤 부호도 다른 부호의 앞부분이 될 수 없어, 별도의 구분자 없이 해독(Decoding)이 가능함. |

### 3.2 알고리즘 수행 단계
1.  **빈도 산출**: 데이터 내 각 문자의 출현 빈도를 계산한다.
2.  **최소 힙(Min Heap) 구성**: 각 문자를 노드로 만들고 빈도를 키값으로 하여 최소 힙에 삽입한다.
3.  **트리 생성 (Greedy Step)**:
    - 힙에서 빈도가 가장 작은 두 노드를 추출한다.
    - 두 노드를 자식으로 하는 새 부모 노드를 생성하며, 부모의 빈도는 자식 빈도의 합으로 설정한다.
    - 새 노드를 다시 힙에 삽입한다.
    - 노드가 하나 남을 때까지 반복한다.
4.  **부호 할당**: 루트에서 왼쪽 간선은 '0', 오른쪽 간선은 '1'을 부여하여 리프 노드까지의 경로를 부호로 확정한다.

## 4. 허프만 트리 구조 (예시)
문자 집합 {A: 45, B: 13, C: 12, D: 16, E: 9, F: 5} 일 때의 트리 형상화:

```text
              [100]
             /     \
          0/         \1
        [A:45]       [55]
                    /    \
                 0/        \1
               [25]        [30]
              /    \      /    \
           0/     1/    0/     1/
        [C:12] [B:13] [D:16]   [14]
                              /    \
                           0/     1/
                         [F:5]   [E:9]
```

## 5. 성능 및 장단점 분석

| 구분 | 내용 |
| :--- | :--- |
| **시간 복잡도** | $O(n \log n)$ (n은 문자의 종류 수, 최소 힙 사용 시) |
| **장점** | 구현이 비교적 간단하며, 최적의 이진 트리 부호를 보장함 (무손실). |
| **단점** | 압축 해제를 위해 허프만 테이블(상세 빈도 정보)을 함께 전달해야 하므로 오버헤드 발생. |

## 6. 기술사적 판단 (Professional Engineer Judgment)
허프만 코딩은 정적 압축 방식으로서 데이터의 분포를 미리 알고 있을 때 최적의 성능을 발휘한다. 그러나 실시간 스트리밍 데이터나 문자 분포가 계속 변하는 환경에서는 **적응형 허프만 코딩(Adaptive Huffman Coding)**이나 **산술 부호화(Arithmetic Coding)**가 더 유리할 수 있다. 실제 시스템 설계 시에는 압축률뿐만 아니라 부호화/복호화에 소요되는 CPU 연산량과 전송 효율 사이의 **균형점(Trade-off)**을 고려하여 알고리즘을 선택해야 한다.

---

## [부록] 어린이 버전 설명 및 비유

### 📮 우체부 아저씨의 비밀 편지
여러분, 친구들과 비밀 편지를 주고받는다고 생각해 보세요. 그런데 편지지가 너무 작아서 글자를 아주 짧게 써야 해요.

*   **약속하기:** 우리가 가장 자주 쓰는 "안녕"이라는 말은 아주 짧게 **'0'**이라고만 쓰고, 가끔 쓰는 "떡볶이 먹고 싶어"라는 말은 길게 **'1101'**이라고 쓰기로 약속하는 거예요.
*   **비유:** 이건 마치 **자주 쓰는 물건은 방 문 바로 앞에 두고, 가끔 쓰는 물건은 깊은 창고 속에 넣어두는 것**과 같아요. 자주 쓰는 걸 꺼내기 쉽게(짧게) 만들어서 전체적으로 일을 아주 빠르게 끝내는 방법이랍니다!

### 💡 왜 '0'과 '1'만 쓰나요?
컴퓨터는 전기가 통하는지 안 통하는지만 알 수 있는 바보라서 그래요. 하지만 허프만 코딩이라는 마법을 쓰면, 그 바보 같은 컴퓨터도 아주 두꺼운 책을 아주 얇은 종이 한 장처럼 압축해서 기억할 수 있게 된답니다!
