---
layout: note
title: 순서논리회로 (Sequential Logic Circuit)
date: 2026-02-27
---

# 순서논리회로 (Sequential Logic Circuit)

## 어린이를 위한 전체 내용 종합 인사이트 핵심 설명

**스마트폰 잠금화면의 비밀번호 입력**을 생각해보세요. 조합논리회로는 계산기처럼 "지금 누른 버튼"만으로 결과를 내지만, 순서논리회로는 **"이전에 무엇을 눌렀는지 기억"**합니다. 첫 번째 숫자, 두 번째 숫자, 세 번째 숫자... 순서대로 입력해야만 잠금이 풀립니다. 이처럼 **과거의 상태를 기억하고, 그 기억을 바탕으로 현재 입력과 함께 출력을 결정**하는 회로가 순서논리회로입니다. 마치 우리가 "어제 무엇을 먹었는지" 기억하면서 오늘 메뉴를 정하는 것과 같습니다.

---

## 1. 개념

### 정의
**순서논리회로 (Sequential Logic Circuit)**는 출력이 현재의 입력값뿐만 아니라 **과거의 입력 이력(상태)**에도 의존하는 디지털 논리회로입니다. 내부에 **기억 소자(Memory Element)**를 포함하여 이전 상태를 저장하고, 이를 현재 입력과 결합하여 출력을 생성합니다.

### 조합논리회로 (Combinational Logic Circuit)와의 핵심 차이

| 구분 | 조합논리회로 | 순서논리회로 |
|------|-------------|-------------|
| 출력 결정 요소 | 현재 입력만 | 현재 입력 + 이전 상태 |
| 기억 소자 | 없음 | 있음 (플립플롭, 래치 등) |
| 피드백 루프 | 없음 | 있음 |
| 예시 | 가산기, 비교기, 멀티플렉서 | 카운터, 레지스터, 상태머신 |

---

## 2. 등장 배경

### 2.1 조합논리회로의 한계
- **상태 저장 불가**: 입력이 사라지면 출력도 사라짐
- **순차적 처리 불가**: "먼저 A, 다음 B" 같은 순서 처리 불가
- **타이밍 제어 불가**: 클럭 신호와 동기화된 동작 불가

### 2.2 실제 필요성
```
┌─────────────────────────────────────────────────────────────┐
│  현실의 문제: "기억"이 필요한 상황들                          │
├─────────────────────────────────────────────────────────────┤
│  • 엘리베이터: 현재 층수 기억 → 다음 층 결정                  │
│  • 자판기: 투입 금액 누적 → 음료 배출 여부 결정               │
│  • 교통신호: 현재 신호 상태 → 다음 신호 결정                  │
│  • CPU: 명령어 수행 단계 기억 → 다음 단계 수행                │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 구성 요소

### 3.1 기본 구조도

```
                    ┌──────────────────┐
    입력 ──────────▶│   조합논리회로    │──────────▶ 출력
                    │  (Combinational)  │
                    └────────┬─────────┘
                             │
                    ┌────────▼─────────┐
                    │   기억 소자       │
                    │ (Memory Element) │
                    └────────┬─────────┘
                             │
                    현재 상태 (Present State)
```

### 3.2 핵심 구성 요소

| 구성 요소 | 설명 | 예시 |
|----------|------|------|
| **조합논리부** | 입력과 현재 상태를 결합하여 출력 생성 | AND/OR 게이트 배열 |
| **기억 소자** | 1비트 정보를 저장하는 회로 | 플립플롭, 래치 |
| **피드백 루프** | 출력을 다시 입력으로 되먹임 | 상태 전이 경로 |
| **클럭 신호** | 동기화를 위한 주기적 펄스 | Clock (CLK) |

### 3.3 기억 소자 상세

#### 래치 (Latch) vs 플립플롭 (Flip-Flop)

| 구분 | 래치 (Latch) | 플립플롭 (Flip-Flop) |
|------|-------------|---------------------|
| 동작 방식 | **레벨 트리거** (Level Trigger) | **엣지 트리거** (Edge Trigger) |
| 상태 변경 시점 | 클럭이 HIGH/LOW인 동안 | 클럭 상승/하강 에지에서만 |
| 민감도 | 입력 변화에 즉시 반응 | 특정 순간에만 반응 |
| 종류 | SR 래치, D 래치, JK 래치 | D 플립플롭, JK 플립플롭, T 플립플롭 |
| 용도 | 비동기 회로, 파이프라인 | 동기 회로, 카운터, 레지스터 |

---

## 4. 핵심 원리

### 4.1 상태 머신 (State Machine) 모델

순서논리회로는 **유한 상태 머신 (Finite State Machine, FSM)**으로 모델링됩니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    유한 상태 머신 (FSM)                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   S(t+1) = f(입력, S(t))    ... 다음 상태 함수              │
│   출력 = g(입력, S(t))       ... 출력 함수                  │
│                                                             │
│   • S(t): 현재 상태 (Present State)                         │
│   • S(t+1): 다음 상태 (Next State)                          │
│   • f: 상태 전이 함수                                       │
│   • g: 출력 함수                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 FSM의 두 가지 유형

| 유형 | 출력 결정 요소 | 특징 | 예시 |
|------|---------------|------|------|
| **Moore 머신** | 현재 상태만 | 출력이 상태에만 의존, 입력 변화에 즉시 반응 안 함 | 신호등 제어 |
| **Mealy 머신** | 현재 상태 + 입력 | 출력이 상태와 입력 모두에 의존, 더 적은 상태로 구현 가능 | 프로토콜 핸들러 |

### 4.3 동작 원리

```
1. 클럭 엣지 도달
        ↓
2. 기억 소자에서 현재 상태 읽기
        ↓
3. 입력 + 현재 상태 → 조합논리 회로 통과
        ↓
4. 다음 상태 계산 → 기억 소자에 저장
        ↓
5. 출력 생성
        ↓
6. 다음 클럭 엣지까지 대기
```

---

## 5. 대표적 응용 회로

### 5.1 레지스터 (Register)

| 구분 | 설명 |
|------|------|
| **정의** | N비트 데이터를 저장하는 N개 플립플롭 집합 |
| **구조** | 병렬 연결된 D 플립플롭들 |
| **용도** | CPU 내 데이터 임시 저장, 주소 저장 |

### 5.2 카운터 (Counter)

| 종류 | 설명 | 특징 |
|------|------|------|
| **비동기 카운터** | 각 플립플롭이 이전 출력으로 트리거 | 구조 간단, 전파지연 큼 |
| **동기 카운터** | 모든 플립플롭이 동일 클럭 사용 | 빠름, 회로 복잡 |

### 5.3 시프트 레지스터 (Shift Register)

```
데이터 흐름: D_in → [FF0] → [FF1] → [FF2] → [FF3] → D_out
                    ↑       ↑       ↑       ↑
                  CLK     CLK     CLK     CLK (공통)
```

| 모드 | 설명 | 용도 |
|------|------|------|
| **SISO** | 직렬 입력 → 직렬 출력 | 데이터 지연 |
| **SIPO** | 직렬 입력 → 병렬 출력 | 직렬-병렬 변환 |
| **PISO** | 병렬 입력 → 직렬 출력 | 병렬-직렬 변환 |
| **PIPO** | 병렬 입력 → 병렬 출력 | 데이터 저장 |

---

## 6. 장단점

### 6.1 장점

| 장점 | 설명 |
|------|------|
| **상태 저장** | 과거 이력을 기억하여 복잡한 로직 구현 가능 |
| **순차 처리** | 단계별 알고리즘 구현 가능 |
| **동기화** | 클럭 기반 예측 가능한 동작 |
| **제어 용이** | 상태 머신으로 체계적 설계 가능 |

### 6.2 단점

| 단점 | 설명 |
|------|------|
| **속도 제한** | 클럭 주파수 한계, 설정/유지 시간 제약 |
| **복잡도 증가** | 기억 소자 추가로 회로 복잡 |
| **전력 소모** | 클럭 분배 네트워크와 기억 소자의 정적 전력 |
| **타이밍 문제** | 경합 조건(Race Condition), 준안정 상태(Metastability) |

---

## 7. 주요 타이밍 이슈

### 7.1 경합 조건 (Race Condition)

```
문제: 피드백 루프에서 신호 전파 지연 차이로 인한 불안정 상태

┌─────────────────────────────────────────────────────────┐
│  해결 방안:                                              │
│  • 마스터-슬레이브 구조 사용                             │
│  • 엣지 트리거 플립플롭 사용                             │
│  • 적절한 클럭 주기 설계                                 │
└─────────────────────────────────────────────────────────┘
```

### 7.2 타이밍 파라미터

| 파라미터 | 설명 | 일반적 요구사항 |
|----------|------|----------------|
| **Setup Time (t_setup)** | 클럭 엣지 전 입력이 안정되어야 하는 시간 | 데이터 변경 금지 구간 |
| **Hold Time (t_hold)** | 클럭 엣지 후 입력이 유지되어야 하는 시간 | 데이터 변경 금지 구간 |
| **Clock-to-Q (t_CQ)** | 클럭 엣지부터 출력까지 지연 시간 | 최소화 필요 |
| **전파 지연 (t_pd)** | 입력 변화부터 출력 변화까지 시간 | 최대 클럭 주파수 결정 |

```
        Setup Time        Hold Time
    ◀──────────────▶   ◀──────────▶
    ══════════════════╪═════════════════════
                    ▲
                Clock Edge

    최대 동작 주파수: f_max = 1 / (t_setup + t_CQ + t_logic)
```

---

## 8. 비교: 동기식 vs 비동기식

| 구분 | 동기식 순서회로 | 비동기식 순서회로 |
|------|----------------|------------------|
| **클럭** | 사용 | 미사용 |
| **상태 변경** | 클럭 엣지에서만 | 입력 변화 시 즉시 |
| **설계 난이도** | 상대적으로 쉬움 | 복잡 (경합 조건 고려) |
| **속도** | 클럭 주파수 제한 | 이론적으로 더 빠름 |
| **신뢰성** | 높음 | 낮음 (순차 회로 문제) |
| **전력 소모** | 높음 (클럭 네트워크) | 낮음 |
| **주요 용도** | CPU, 메모리, 버스 | 저전력 임베디드, 인터페이스 |

---

## 9. 기술사적 판단

### 9.1 설계 고려사항

```
┌─────────────────────────────────────────────────────────────┐
│  순서논리회로 설계 시 핵심 체크포인트                         │
├─────────────────────────────────────────────────────────────┤
│  1. 상태 최소화: FSM 상태 수 최적화                          │
│  2. 타이밍 여유: Setup/Hold Time 마진 확보                   │
│  3. 클럭 품질: 스큐(Skew), 지터(Jitter) 최소화               │
│  4. 전력 최적화: 클럭 게이팅, 전압 스케일링                  │
│  5. 테스트 용이성: 스캔 체인, JTAG 설계                      │
└─────────────────────────────────────────────────────────────┘
```

### 9.2 현업 관점

| 관점 | 고려사항 |
|------|---------|
| **성능** | 파이프라이닝으로 처리량 향상, 임계 경로 최적화 |
| **전력** | 클럭 게이팅, 파워 게이팅, 저전력 플립플롭 사용 |
| **면적** | 상태 인코딩 최적화, 리소스 공유 |
| **신뢰성** | 준안정 상태 해결, EDC (Error Detection Code) |

---

## 10. 미래 전망

### 10.1 기술 발전 방향

| 분야 | 발전 방향 |
|------|---------|
| **고속화** | 수 GHz 클럭, 시리얼 통신 기반 동기화 |
| **저전력** | 근임계 전압 동작, 비동기-동기 하이브리드 |
| **신뢰성** | Radiation-hardened 설계, 자가 복구 회로 |
| **AI 가속** | 스파이킹 뉴럴 네트워크용 이벤트 기반 회로 |

### 10.2 신흥 기술

```
┌─────────────────────────────────────────────────────────────┐
│  차세대 순서논리회로 기술                                    │
├─────────────────────────────────────────────────────────────┤
│  • Clockless Computing: 클럭 없는 완전 비동기 회로           │
│  • Neuromorphic: 뇌 신경망 모방 이벤트 기반 회로             │
│  • Quantum Sequential: 양자 상태를 활용한 순차 회로          │
│  • 3D Integration: 적층형 메모리-로직 융합 설계              │
└─────────────────────────────────────────────────────────────┘
```

---

## 11. 요약

```
┌─────────────────────────────────────────────────────────────┐
│                    순서논리회로 핵심 요약                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  정의: 입력 + 이전 상태 → 출력 (기억 소자 포함)             │
│                                                             │
│  구성: 조합논리부 + 기억 소자 + 피드백 루프 + 클럭          │
│                                                             │
│  핵심 원리: FSM (Moore/Mealy 머신)으로 모델링               │
│                                                             │
│  주요 응용: 레지스터, 카운터, 시프트 레지스터, CPU           │
│                                                             │
│  설계 포인트: 타이밍(Setup/Hold), 경합 조건 해결             │
│                                                             │
│  트렌드: 고속·저전력·신뢰성·AI 융합                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 참고 자료

- 플립플롭과 래치 상세: `flipflop_latch.md`
- 조합논리회로: `comparator.md`, `multiplexer_demultiplexer.md`
