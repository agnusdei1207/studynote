---
layout: default
title: 시프터와 곱셈/나눗셈의 관계
---

# 시프터와 곱셈/나눗셈의 관계

## 어린이를 위한 전체 내용 종합 인사이트 핵심 설명

**10진수에서 한 자리 옮기면 어떻게 될까요?**
> 123에 10을 곱하면 → **1230** (왼쪽으로 1칸 이동, 0 추가)
> 1230을 10으로 나누면 → **123** (오른쪽으로 1칸 이동, 0 제거)

**2진수에서도 똑같아요! 대신 10이 아니라 2로!**
> 101₂ (5)를 왼쪽으로 1칸 → **1010₂ (10)** → **2배!**
> 1010₂ (10)를 오른쪽으로 1칸 → **101₂ (5)** → **2로 나눔!**

**핵심 공식:**
```
왼쪽 시프트 (<<) = × 2ⁿ
오른쪽 시프트 (>>) = ÷ 2ⁿ
```

---

## 1. 개념

### 1.1 시프트 연산 (Shift Operation)

**시프트 연산**은 비트를 왼쪽이나 오른쪽으로 이동시키는 연산입니다. 각 비트가 한 자리씩 이동하면 **자릿수가 2배(또는 1/2배)** 변하므로 곱셈/나눗셈과 같은 효과를 냅니다.

### 1.2 시프트 종류

| 시프트 종류 | 방향 | 수학적 의미 | 예시 |
|-------------|------|-------------|------|
| **왼쪽 시프트** | << | × 2ⁿ | 5 << 1 = 10 |
| **논리 오른쪽 시프트** | >> | ÷ 2ⁿ (unsigned) | 10 >> 1 = 5 |
| **산술 오른쪽 시프트** | >>> | ÷ 2ⁿ (signed) | -8 >> 2 = -2 |

---

## 2. 왼쪽 시프트와 곱셈

### 2.1 원리

```
왼쪽으로 n비트 시프트 = 2ⁿ을 곱함

예: 101₂ (5) << 1
    ┌───┬───┬───┬───┐
    │ 0 │ 1 │ 0 │ 1 │   →   5
    └───┴───┴───┴───┘
          ↓ 왼쪽으로 1칸
    ┌───┬───┬───┬───┐
    │ 1 │ 0 │ 1 │ 0 │   →   10  (= 5 × 2)
    └───┴───┴───┴───┘
```

### 2.2 상세 예시

| 10진수 | 2진수 | << 1 (1칸) | << 2 (2칸) | << 3 (3칸) |
|--------|-------|------------|------------|------------|
| 1 | 0001 | 0010 = **2** | 0100 = **4** | 1000 = **8** |
| 3 | 0011 | 0110 = **6** | 1100 = **12** | 11000 = **24** |
| 5 | 0101 | 1010 = **10** | 10100 = **20** | 101000 = **40** |
| 7 | 0111 | 1110 = **14** | 11100 = **28** | 111000 = **56** |

### 2.3 수학적 증명

```
n비트 왼쪽 시프트:

원래 값:  (bₙ₋₁ × 2ⁿ⁻¹) + (bₙ₋₂ × 2ⁿ⁻²) + ... + (b₁ × 2¹) + (b₀ × 2⁰)

시프트 후: (bₙ₋₁ × 2ⁿ) + (bₙ₋₂ × 2ⁿ⁻¹) + ... + (b₁ × 2²) + (b₀ × 2¹)
         = 2 × [(bₙ₋₁ × 2ⁿ⁻¹) + (bₙ₋₂ × 2ⁿ⁻²) + ... + (b₁ × 2¹) + (b₀ × 2⁰)]
         = 2 × (원래 값)

결론: 1비트 왼쪽 시프트 = × 2
      n비트 왼쪽 시프트 = × 2ⁿ
```

### 2.4 곱셈 구현 예시

**5 × 6 = 30을 시프트와 덧셈으로 계산:**

```
5 = 101₂
6 = 110₂ = 4 + 2 = 2² + 2¹

5 × 6 = 5 × (4 + 2)
      = (5 × 4) + (5 × 2)
      = (5 << 2) + (5 << 1)
      = 10100₂ + 01010₂
      = 11110₂
      = 30 ✓
```

---

## 3. 오른쪽 시프트와 나눗셈

### 3.1 원리

```
오른쪽으로 n비트 시프트 = 2ⁿ으로 나눔 (나머지 버림)

예: 1010₂ (10) >> 1
    ┌───┬───┬───┬───┐
    │ 1 │ 0 │ 1 │ 0 │   →   10
    └───┴───┴───┴───┘
          ↓ 오른쪽으로 1칸
    ┌───┬───┬───┬───┐
    │ 0 │ 1 │ 0 │ 1 │   →   5  (= 10 ÷ 2)
    └───┴───┴───┴───┘
```

### 3.2 상세 예시

| 10진수 | 2진수 | >> 1 (1칸) | >> 2 (2칸) | >> 3 (3칸) |
|--------|-------|------------|------------|------------|
| 16 | 10000 | 01000 = **8** | 00100 = **4** | 00010 = **2** |
| 15 | 01111 | 00111 = **7** | 00011 = **3** | 00001 = **1** |
| 10 | 01010 | 00101 = **5** | 00010 = **2** | 00001 = **1** |
| 8 | 01000 | 00100 = **4** | 00010 = **2** | 00001 = **1** |

### 3.3 나눗셈에서 나머지 처리

```
7 ÷ 2 = 3 (나머지 1)

7 = 0111₂
7 >> 1 = 0011₂ = 3

나머지는 어디 갔나?
→ 맨 오른쪽 비트가 1이었음 → 이 비트는 시프트하며 버려짐
→ 버려진 비트 = 나머지!
```

### 3.4 논리 vs 산술 오른쪽 시프트

| 구분 | 논리 시프트 (Logical) | 산술 시프트 (Arithmetic) |
|------|---------------------|------------------------|
| **빈 자리 채움** | 항상 0으로 채움 | 부호비트(Sign bit)로 채움 |
| **음수 처리** | 음수 → 양수로 변형됨 | 음수 유지 |
| **용도** | Unsigned 정수 | Signed 정수 |

**예시 (4비트 2의 보수):**
```
-4 = 1100₂

논리 시프트 >> 1: 0110₂ = 6  (잘못됨!)
산술 시프트 >> 1: 1110₂ = -2 (올바름! -4 ÷ 2 = -2)

산술 시프트는 MSB(부호비트)를 유지하며 채움
```

---

## 4. 10진수와 2진수 비교

### 4.1 자릿수 이동의 의미

```
┌─────────────────────────────────────────────────────────────┐
│              10진수 vs 2진수 시프트 비교                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  10진수: 왼쪽 1칸 = × 10    오른쪽 1칸 = ÷ 10               │
│                                                             │
│  예: 123 → 1230 (×10)                                       │
│      1230 → 123 (÷10)                                       │
│                                                             │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  2진수: 왼쪽 1칸 = × 2      오른쪽 1칸 = ÷ 2                │
│                                                             │
│  예: 101 (5) → 1010 (10)                                    │
│      1010 (10) → 101 (5)                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 일반화

| 진수 | 기수 (Base) | 왼쪽 시프트 | 오른쪽 시프트 |
|------|-------------|-------------|---------------|
| 2진수 | 2 | × 2ⁿ | ÷ 2ⁿ |
| 8진수 | 8 | × 8ⁿ | ÷ 8ⁿ |
| 10진수 | 10 | × 10ⁿ | ÷ 10ⁿ |
| 16진수 | 16 | × 16ⁿ | ÷ 16ⁿ |

---

## 5. 하드웨어 구현: 시프터 (Shifter)

### 5.1 바렐 시프터 (Barrel Shifter)

**바렐 시프터**는 한 클럭 사이클에 여러 비트를 동시에 시프트할 수 있는 회로입니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    바렐 시프터 구조                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  입력: A₃ A₂ A₁ A₀                                         │
│                                                             │
│  제어 신호: SH₁ SH₀ (시프트 양)                             │
│                                                             │
│           SH₁ SH₀    동작                                   │
│           ────────────────                                  │
│            0   0    시프트 없음                             │
│            0   1    1비트 시프트                            │
│            1   0    2비트 시프트                            │
│            1   1    3비트 시프트                            │
│                                                             │
│  출력: Y₃ Y₂ Y₁ Y₀                                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 멀티플렉서 기반 구현

```
1비트 왼쪽 시프터:

A₃ ─┬─────────────────► Y₃
    │
    └──► [MUX] ────────► Y₂
          ↑
A₂ ───────┘

A₂ ─┬─────────────────► Y₂ (shift=0)
    │
    └──► [MUX] ────────► Y₁ (shift=1)
          ↑
A₁ ───────┘

... 이하 동일

Shift 제어 신호가 0이면 그대로, 1이면 1비트 왼쪽으로 이동
```

### 5.3 ALU에서의 활용

```
┌─────────────────────────────────────────────────────────────┐
│                    ALU 구조                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    A ──┬──► [가산기] ──┐                                    │
│         │               │                                   │
│         │   [시프터] ───┼──► 결과                           │
│         │               │                                   │
│    B ───┴──► [AND/OR] ─┘                                    │
│                                                             │
│  시프터로 곱셈/나눗셈을 빠르게 수행                          │
│  (실제 곱셈기/나눗셈기보다 훨씬 간단)                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6. 실제 응용

### 6.1 효율적인 곱셈 알고리즘

**곱셈 = 시프트 + 덧셈 조합**

```
13 × 11 = ?

11 = 1011₂ = 8 + 2 + 1 = 2³ + 2¹ + 2⁰

13 × 11 = (13 << 3) + (13 << 1) + (13 << 0)
        = 104 + 26 + 13
        = 143 ✓

컴파일러 최적화:
  a × 10 → (a << 3) + (a << 1)  // 8a + 2a = 10a
  a × 15 → (a << 4) - a         // 16a - a = 15a
```

### 6.2 비트 마스킹과 결합

```
특정 비트 추출:

값 & (1 << n)   → n번째 비트가 1인지 확인
값 | (1 << n)   → n번째 비트를 1로 설정
값 & ~(1 << n)  → n번째 비트를 0으로 클리어
값 ^ (1 << n)   → n번째 비트 토글
```

### 6.3 그래픽스/게임 프로그래밍

```
고정소수점 연산:

16.16 고정소수점 형식 (정수부 16비트, 소수부 16비트)

픽셀 좌표 × 2: 좌표 << 1
픽셀 좌표 ÷ 2: 좌표 >> 1

텍스처 좌표 계산, 충돌 감지 등에서 빠른 연산
```

---

## 7. 장단점

### 7.1 시프트 기반 곱셈/나눗셈의 장점

| 장점 | 설명 |
|------|------|
| **속도** | 하드웨어 시프트는 매우 빠름 (1 클럭) |
| **단순성** | 곱셈기/나눗셈기보다 회로 간단 |
| **전력** | 적은 게이트로 구현 가능 |
| **면적** | 칩 면적 절약 |

### 7.2 제한사항

| 제한 | 설명 |
|------|------|
| **2의 거듭제곱만** | 2, 4, 8, 16... 배만 가능 |
| **일반 곱셈 불가** | 13배 같은건 시프트+덧셈 조합 필요 |
| **오버플로우** | 왼쪽 시프트 시 자릿수 초과 주의 |
| **반올림 없음** | 나눗셈은 항상 버림 |

---

## 8. 기술사적 판단

### 8.1 언제 시프트를 쓸까?

```
┌─────────────────────────────────────────────────────────────┐
│  시프트 사용 판단 기준                                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  곱셈/나눗셈 대상이 2의 거듭제곱인가?                        │
│       │                                                     │
│       ├── YES ──► 시프트 사용 (×2ⁿ → << n)                  │
│       │                                                     │
│       └── NO                                                │
│            │                                                │
│            ├── 2의 거듭제곱 합으로 표현 가능?                │
│            │    │                                           │
│            │    ├── YES ──► 시프트 + 덧셈 조합               │
│            │    │         (예: ×10 = ×8 + ×2)               │
│            │    │                                           │
│            │    └── NO ──► 곱셈기/나눗셈기 사용              │
│            │                                                │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 컴파일러 최적화 예시

```c
// 소스 코드
int x = a * 8;
int y = b / 4;
int z = c * 10;

// 컴파일러 최적화 후
int x = a << 3;           // × 8 = << 3
int y = b >> 2;           // ÷ 4 = >> 2
int z = (c << 3) + (c << 1);  // × 10 = × 8 + × 2
```

### 8.3 성능 비교

| 연산 | 곱셈기 사용 | 시프트 사용 | 속도 차이 |
|------|------------|-------------|-----------|
| × 2 | 3-5 클럭 | 1 클럭 | **3-5배 빠름** |
| × 4 | 3-5 클럭 | 1 클럭 | **3-5배 빠름** |
| × 8 | 3-5 클럭 | 1 클럭 | **3-5배 빠름** |
| ÷ 2 | 10-20 클럭 | 1 클럭 | **10-20배 빠름** |

---

## 9. 요약

```
┌─────────────────────────────────────────────────────────────┐
│                시프트와 곱셈/나눗셈 핵심 요약                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  왼쪽 시프트 (<< n)  =  × 2ⁿ                                │
│  오른쪽 시프트 (>> n) =  ÷ 2ⁿ (버림)                        │
│                                                             │
│  10진수에서 10배 = 왼쪽 1칸                                 │
│  2진수에서 2배 = 왼쪽 1칸                                   │
│                                                             │
│  왜? 각 비트가 2ⁿ 자릿수를 가지므로                         │
│      한 칸 이동하면 자릿수가 2배(또는 1/2배) 변함           │
│                                                             │
│  응용:                                                      │
│  • × 10 = << 3 + << 1 (8 + 2 = 10)                         │
│  • × 100 = << 6 + << 5 + << 2 (64+32+4=100)                │
│  • 비트 마스킹: (1 << n)으로 n번째 비트 조작                │
│                                                             │
│  하드웨어: 바렐 시프터로 1클럭에 다중 비트 시프트            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 부록: 어린이를 위한 설명

### 10진수에서 시작해요

**123이 있어요.**

> 123 뒤에 0을 붙이면 → **1230** (10배 커짐!)
> 1230에서 0을 떼면 → **123** (10으로 나눔!)

이게 바로 **자릿수 이동**이에요!

### 2진수도 똑같아요

**101₂ (5)가 있어요.**

> 왼쪽으로 한 칸 → **1010₂ (10)** → **2배!**
> 오른쪽으로 한 칸 → **10₂ (2)** → **2로 나눔!**

### 왜 그럴까요?

```
10진수:  1    2    3
        ↓    ↓    ↓
       100   10   1   (각 자리는 10배씩 차이)

2진수:   1    0    1
        ↓    ↓    ↓
        4    2    1   (각 자리는 2배씩 차이)
```

**한 칸 이동하면 자릿수가 2배(또는 1/2배) 변해요!**

### 게임으로 생각해요

| 레벨 | 2진수 | 10진수 |
|------|-------|--------|
| 레벨 1 | 1 | 1 |
| 레벨 2 | 10 | 2 |
| 레벨 3 | 100 | 4 |
| 레벨 4 | 1000 | 8 |
| 레벨 5 | 10000 | 16 |

**왼쪽으로 한 칸 = 레벨 업 = 2배!**

### 외울 공식

```
<< 1 = × 2    (왼쪽 1칸 = 2배)
<< 2 = × 4    (왼쪽 2칸 = 4배)
<< 3 = × 8    (왼쪽 3칸 = 8배)

>> 1 = ÷ 2    (오른쪽 1칸 = 반으로)
>> 2 = ÷ 4    (오른쪽 2칸 = 1/4로)
>> 3 = ÷ 8    (오른쪽 3칸 = 1/8로)
```
