---
layout: note
title: 오류 검출 및 정정 코드 비교 분석
date: 2026-02-27
---

# 오류 검출 및 정정 코드 비교 분석

## 1. 개념

### 1.1 정의
오류 검출 및 정정 코드(Error Detection and Correction Code, EDAC)는 데이터 전송이나 저장 중 발생할 수 있는 오류를 식별하고 수정하기 위한 기법이다. 신뢰성 있는 데이터 통신과 메모리 시스템의 핵심 기술이다.

### 1.2 오류의 종류

| 오류 유형 | 설명 | 발생 원인 |
|----------|------|----------|
| 단일 비트 오류 (Single-bit Error) | 1비트만 변형됨 | 방사선, 전원 노이즈 |
| 다중 비트 오류 (Multiple-bit Error) | 여러 비트가 변형됨 | 버스트 노이즈 |
| 버스트 오류 (Burst Error) | 연속된 비트들이 변형됨 | 케이블 간섭, 저장 매체 결함 |

## 2. 등장 배경

### 2.1 문제 인식
- 1940년대: 초기 컴퓨터에서 메모리 오류 발생
- 1960년대: 위성 통신에서 신호 왜곡 문제
- 통신 채널의 불완전성과 잡음(Noise)으로 인한 데이터 손상

### 2.2 발전 과정

```
1948년 ──► 1950년 ──► 1961년 ──► 1960년대 ──► 1970년대
 셰넌      해밍       CRC        2차원 패리티    SECDED
이론       코드      개발        발전           개발
```

## 3. 구성 요소 비교

### 3.1 비교 표

| 구분 | 패리티 비트 | 2차원 패리티 | 해밍 코드 | CRC | SECDED |
|------|------------|--------------|-----------|-----|--------|
| **추가 비트 수** | 1 | n + m (행+열) | r (2^r ≥ n+r+1) | 8~32 | 약 2r |
| **검출 능력** | 단일 비트 | 단일/다중/버스트 | 다중 비트 | 버스트 오류 | 2비트까지 |
| **정정 능력** | 불가 | 일부 가능 | 단일 비트 정정 | 불가 | 단일 비트 정정 |
| **오버헤드** | 최소 | 중간 | 중간 | 중간 | 높음 |
| **주요 적용** | 단순 시스템 | 데이터 전송 | 메모리 시스템 | 네트워크 | 고신뢰 시스템 |
| **복잡도** | O(1) | O(n×m) | O(log n) | O(n) | O(log n) |

## 4. 핵심 원리

### 4.1 패리티 비트 (Parity Bit)

#### 동작 원리
```
데이터: 1 0 1 1 0
짝수 패리티: 1 0 1 1 0 | 1  (1의 개수가 짝수가 되도록)
홀수 패리티: 1 0 1 1 0 | 0  (1의 개수가 홀수가 되도록)
```

#### 특징
- 가장 단순한 오류 검출 방식
- 1비트만 추가하므로 오버헤드 최소
- 단일 비트 오류만 검출 가능
- 오류 정정 불가능

### 4.2 2차원 패리티 (2-Dimensional Parity)

#### 동작 원리
```
        데이터 비트           행 패리티
    ┌─────────────────┬───┐
    │  1  0  1  1  0  │ 1 │ ← 행 패리티
    │  0  1  1  0  1  │ 1 │
    │  1  1  0  0  1  │ 0 │
    ├─────────────────┼───┤
    │  0  0  0  1  0  │ 1 │ ← 열 패리티
    └─────────────────┴───┘
           열 패리티
```

#### 특징
- 행과 열 양방향으로 패리티 계산
- 오류 위치 식별 가능 (교차점)
- 단일 비트 오류 정정 가능
- 버스트 오류 검출에 효과적

### 4.3 해밍 코드 (Hamming Code)

#### 동작 원리
```
위치:  1   2   3   4   5   6   7
     ┌───┬───┬───┬───┬───┬───┬───┐
     │P1 │P2 │D1 │P4 │D2 │D3 │D4 │
     └───┴───┴───┴───┴───┴───┴───┘
       ↓   ↓       ↓
      2^0 검사 그룹
       ↓       ↓       ↓
      2^1 검사 그룹
               ↓           ↓
              2^2 검사 그룹

P1: 위치 1,3,5,7 검사
P2: 위치 2,3,6,7 검사
P4: 위치 4,5,6,7 검사
```

#### 검사 행렬 (Parity Check Matrix)
```
     P1 P2 D1 P4 D2 D3 D4
  ┌──────────────────────┐
G1│ 1  0  1  0  1  0  1 │
G2│ 0  1  1  0  0  1  1 │
G3│ 0  0  0  1  1  1  1 │
  └──────────────────────┘
```

#### 오류 정정 과정
1. 각 검사 그룹의 패리티 재계산
2. 신드롬(Syndrome) = 검사 결과 조합
3. 신드롬 값 = 오류 비트 위치
4. 해당 비트 플립(Flip)하여 정정

#### 공식
```
필요한 패리티 비트 수: 2^r ≥ n + r + 1
- n: 데이터 비트 수
- r: 패리티 비트 수
```

### 4.4 순환 중복 검사 (Cyclic Redundancy Check, CRC)

#### 동작 원리
```
데이터: 1 1 0 1 0 1
생성 다항식: x³ + x + 1 → 1 0 1 1

데이터 × x³: 1 1 0 1 0 1 0 0 0
            ÷ 1 0 1 1
            ─────────
나머지: 0 0 1 (CRC 값)

전송: 1 1 0 1 0 1 0 0 1
```

#### 주요 생성 다항식

| 표준 | 다항식 | 비트 수 | 적용 분야 |
|------|--------|---------|----------|
| CRC-8 | x⁸ + x² + x + 1 | 8 | 단거리 통신 |
| CRC-16 | x¹⁶ + x¹⁵ + x² + 1 | 16 | USB, Modbus |
| CRC-32 | x³² + x²⁶ + x²³ + ... + 1 | 32 | 이더넷, ZIP |

#### 특징
- 다항식 연산 기반
- 하드웨어 구현 용이 (시프트 레지스터)
- 긴 버스트 오류 검출에 강함
- 오류 정정 불가 (검출만 가능)

### 4.5 SECDED (Single Error Correction, Double Error Detection)

#### 동작 원리
```
해밍 코드 + 전체 패리티 비트

     ┌─────────────────────────┬───┐
     │    해밍 코드 영역         │ P │
     │  (단일 비트 정정 가능)    │   │
     └─────────────────────────┴───┘
                               ↑
                        전체 패리티
```

#### 오류 처리 로직
```
┌──────────────┬────────────┬──────────────┐
│ 신드롬 = 0   │ 패리티 = 0 │ 오류 없음    │
├──────────────┼────────────┼──────────────┤
│ 신드롬 ≠ 0   │ 패리티 = 1 │ 단일 비트 오류│
│              │            │ → 정정 가능   │
├──────────────┼────────────┼──────────────┤
│ 신드롬 ≠ 0   │ 패리티 = 0 │ 2비트 오류   │
│              │            │ → 검출만 가능│
├──────────────┼────────────┼──────────────┤
│ 신드롬 = 0   │ 패리티 = 1 │ 패리티 비트   │
│              │            │   오류       │
└──────────────┴────────────┴──────────────┘
```

#### 특징
- 해밍 코드 확장版
- 단일 비트 오류 정정 + 2비트 오류 검출
- 높은 신뢰성 요구 시스템에 적용
- 우주선, 서버 메모리 등

## 5. 수학적 원리 쉽게 이해하기

> 🎯 **이 섹션은 수학을 잘 모르는 분들을 위한 친절한 풀이입니다!**

### 5.1 복잡도(Complexity)가 뭐죠?

#### 쉬운 설명
복잡도 = **"데이터가 커질수록 계산 시간이 얼마나 늘어나는가?"**

```
데이터 10개 → 0.01초
데이터 100개 → ?초
```

#### 4가지 복잡도 비교

| 표기 | 의미 | 쉬운 비유 | 예시 |
|------|------|----------|------|
| **O(1)** | 데이터 크기 상관없이 일정 | 엘리베이터 버튼 누르기 | 패리티 비트 |
| **O(n)** | 데이터 크기만큼 선형 증가 | 책 한 권 다 읽기 | CRC |
| **O(log n)** | 데이터가 2배여도 조금만 더 걸림 | 사전에서 단어 찾기 (이분탐색) | 해밍 코드 |
| **O(n×m)** | 가로×세로 모두 검사 | 바둑판 전체 훑기 | 2차원 패리티 |

#### 구체적인 비교

```
데이터 1,000개일 때:

O(1)    → 1번만 계산          ████ (0.001초)
O(log n)→ 약 10번 계산        ████████████ (0.01초)
O(n)    → 1,000번 계산        ████████████████████████ (1초)
O(n×m)  → 1,000,000번 계산    ████████████████████████████ (1000초)
```

### 5.2 해밍 코드 공식 완전 정복

#### 공식
```
2^r ≥ n + r + 1
```

#### 각 기호의 의미
| 기호 | 의미 | 예시 |
|------|------|------|
| n | 데이터 비트 수 | 4비트 데이터면 n = 4 |
| r | 패리티 비트 수 | 우리가 구해야 할 값! |
| 2^r | 가능한 상태 수 | r=3이면 2³ = 8가지 |
| n + r + 1 | 필요한 상태 수 | 데이터 + 패리티 + 정상(1) |

#### 왜 이 공식이 필요할까?

**핵심 아이디어**: "모든 비트 위치마다 고유한 검사 결과를 만들어야 한다"

```
┌─────────────────────────────────────────────────┐
│  4비트 데이터를 보호하려면 몇 개의 패리티가 필요? │
└─────────────────────────────────────────────────┘

Step 1: 가능한 경우의 수 세기
- 4개 데이터 비트 각각이 틀릴 수 있음 → 4가지
- 패리티 비트도 틀릴 수 있음 → r가지
- 아무것도 안 틀릴 수도 있음 → 1가지
- 총 필요한 경우: 4 + r + 1 = 5 + r

Step 2: 패리티 비트로 구분 가능한 경우의 수
- 패리티 r개로 만들 수 있는 조합: 2^r가지
  (r=1이면 2가지, r=2면 4가지, r=3이면 8가지...)

Step 3: 대입해보기

r = 1일 때: 2¹ = 2  vs  4 + 1 + 1 = 6   → 2 < 6 ✗ (부족!)
r = 2일 때: 2² = 4  vs  4 + 2 + 1 = 7   → 4 < 7 ✗ (부족!)
r = 3일 때: 2³ = 8  vs  4 + 3 + 1 = 8   → 8 = 8 ✓ (딱 맞음!)

정답: 4비트 데이터에는 3개의 패리티 비트가 필요!
```

#### 연습문제 풀이

**Q: 8비트 데이터를 보호하려면 패리티 비트가 몇 개 필요한가?**

```
n = 8

r = 3일 때: 2³ = 8  vs  8 + 3 + 1 = 12   → 8 < 12 ✗
r = 4일 때: 2⁴ = 16 vs  8 + 4 + 1 = 13   → 16 > 13 ✓

정답: 4개의 패리티 비트 필요
```

**Q: 16비트 데이터를 보호하려면?**

```
n = 16

r = 4일 때: 16 vs 16+4+1=21   → 16 < 21 ✗
r = 5일 때: 32 vs 16+5+1=22   → 32 > 22 ✓

정답: 5개의 패리티 비트 필요
```

### 5.3 CRC 다항식 연산 쉽게 이해하기

#### 다항식이 뭔가요?

```
수학에서: x³ + x + 1

이진수로: 1·x³ + 0·x² + 1·x + 1·1
          ↓       ↓       ↓     ↓
         1       0       1     1

즉, x³ + x + 1 = 1011 (이진수)
```

#### XOR 연산 (배타적 논리합)

```
XOR 규칙: 같으면 0, 다르면 1

0 XOR 0 = 0  (같음)
0 XOR 1 = 1  (다름)
1 XOR 0 = 1  (다름)
1 XOR 1 = 0  (같음)

쉬운 기억: "둘 중 하나만 1일 때 1"
```

#### CRC 계산 단계별 풀이

**문제: 데이터 1101을 다항식 1011로 CRC 계산하기**

```
Step 1: 데이터 뒤에 0 추가 (다항식 길이 - 1개만큼)
        1011은 4비트 → 3개의 0 추가
        1101 → 1101000

Step 2: 나눗셈 (XOR로!)

        1101000 ÷ 1011

        1101000
        1011    ← 첫 번째 XOR
        -----
         1100   ← 결과
         1011   ← 두 번째 XOR
         ----
          1110
          1011  ← 세 번째 XOR
          ----
           1010
           1011 ← 네 번째 XOR
           ----
            001 ← 나머지! (CRC 값)

Step 3: 전송 데이터 = 원본 + CRC
        1101 + 001 = 1101001
```

#### 받는 쪽에서 검증

```
받은 데이터: 1101001
같은 다항식으로 나누기: 1101001 ÷ 1011

나머지가 000이면 → 오류 없음 ✓
나머지가 000이 아니면 → 오류 있음 ✗
```

### 5.4 신드롬(Syndrome) 쉽게 이해하기

#### 신드롬이란?
**"오류 위치를 알려주는 비밀 코드"**

#### 해밍 코드 예제로 배우기

```
7비트 해밍 코드: P1 P2 D1 P4 D2 D3 D4
                 1  2   3  4   5   6   7  (위치)

검사 그룹:
- P1 검사: 위치 1,3,5,7 → 1,3,5,7의 XOR = 0 이어야 정상
- P2 검사: 위치 2,3,6,7 → 2,3,6,7의 XOR = 0 이어야 정상
- P4 검사: 위치 4,5,6,7 → 4,5,6,7의 XOR = 0 이어야 정상
```

#### 오류 찾기 실습

**상황: 5번 비트가 틀렸다고 가정**

```
정상 데이터:  1  0  1  0  1  1  0
오류 데이터:  1  0  1  0  0  1  0  (5번이 1→0으로 바뀜)
              ↑  ↑  ↑  ↑  ↑  ↑  ↑
              1  2  3  4  5  6  7

검사 수행:

P1 검사 (1,3,5,7): 1 XOR 1 XOR 0 XOR 0 = 0 → 이상없... 아님!
                   정상이어야 할 값과 다름 → 검사 실패 = 1

P2 검사 (2,3,6,7): 0 XOR 1 XOR 1 XOR 0 = 0 → 정상
                   검사 통과 = 0

P4 검사 (4,5,6,7): 0 XOR 0 XOR 1 XOR 0 = 1 → 이상있음
                   검사 실패 = 1

신드롬 = P4 P2 P1 = 1 0 1 (이진수) = 5 (십진수)

결론: "5번 비트가 틀렸습니다!"
```

#### 신드롬 매직의 비밀

```
위치별 신드롬 값:

위치 1: P1만 검사  → 신드롬 = 001 = 1
위치 2: P2만 검사  → 신드롬 = 010 = 2
위치 3: P1,P2 검사 → 신드롬 = 011 = 3
위치 4: P4만 검사  → 신드롬 = 100 = 4
위치 5: P1,P4 검사 → 신드롬 = 101 = 5 ← 요렇게!
위치 6: P2,P4 검사 → 신드롬 = 110 = 6
위치 7: 전부 검사  → 신드롬 = 111 = 7

신드롬 값 = 오류 위치 (놀랍죠?)
```

### 5.5 2의 보수 vs XOR 차이점

| 연산 | 설명 | 예시 | 오류 정정에서 용도 |
|------|------|------|-------------------|
| XOR | 같으면 0, 다르면 1 | 1⊕1=0, 1⊕0=1 | 패리티 계산 |
| 2의 보수 | 음수 표현 | 5의 2의 보수 = -5 | 덧셈 기반 코드 |

```
XOR로 오류 정정:

오류 비트: 1
정상 비트: 0

1 XOR 1 = 0  ← 오류 비트에 1을 XOR하면 정정됨!

이것이 해밍 코드, SECDED의 핵심 원리
```

### 5.6 복잡도 계산 실제 예시

#### 패리티 비트: O(1)

```
데이터: 1 0 1 1 0 0 1 1 0 1 ... (1000비트)

작업: 1의 개수가 짝수인지 홀수인지만 확인

10비트나 1000비트나 1,000,000비트나
→ "전체 XOR 한 번"으로 끝!

복잡도: O(1) = 데이터 크기와 무관하게 일정
```

#### CRC: O(n)

```
데이터 n비트를 한 번씩 다 훑어야 함

10비트 → 10번 연산
1000비트 → 1000번 연산
1000000비트 → 1000000번 연산

복잡도: O(n) = 데이터 크기에 비례
```

#### 해밍 코드: O(log n)

```
핵심: 검사 그룹 수가 log₂(n)개면 충분

데이터 8비트 → 검사 그룹 3개 (log₂8 = 3)
데이터 64비트 → 검사 그룹 6개 (log₂64 = 6)
데이터 1024비트 → 검사 그룹 10개 (log₂1024 = 10)

데이터가 2배 늘어도 검사는 1개만 더 늘어남!

복잡도: O(log n) = 데이터가 커져도 조금만 늘어남
```

#### 2차원 패리티: O(n×m)

```
8×8 데이터 블록 (64비트)

행 검사: 8번
열 검사: 8번
총: 64번 (8×8)

16×16 블록 (256비트)
총: 256번 (16×16)

복잡도: O(n×m) = 가로×세로, 제곱으로 늘어남
```

---

## 6. 성능 비교

### 6.1 오버헤드 분석

```
데이터 비트: 8비트 기준

┌─────────────┬───────────┬─────────────┐
│   방식      │ 추가 비트 │ 오버헤드(%) │
├─────────────┼───────────┼─────────────┤
│ 패리티      │    1      │   12.5%     │
│ 2차원 패리티│   4~6     │   50~75%    │
│ 해밍 코드   │    4      │   50%       │
│ CRC-8       │    8      │   100%      │
│ SECDED      │    5      │   62.5%     │
└─────────────┴───────────┴─────────────┘
```

### 6.2 검출/정정 능력 비교

```
검출 능력:
패리티 ──────► 2차원 ──────► 해밍 ──────► SECDED
  ↓              ↓            ↓            ↓
단일비트     다중/버스트   다중비트     2비트까지
                                    (CRC: 버스트 우수)

정정 능력:
불가 ──────► 일부 ──────► 단일비트 ──────► 단일비트+2비트검출
(패리티)   (2차원)      (해밍)         (SECDED)
```

### 6.3 구현 복잡도

| 방식 | 하드웨어 | 소프트웨어 | 지연 시간 |
|------|----------|------------|----------|
| 패리티 | 매우 간단 | 매우 간단 | 1 클럭 |
| 2차원 패리티 | 중간 | 중간 | O(n×m) |
| 해밍 코드 | 중간 | 중간 | O(log n) |
| CRC | 간단(LFSR) | 복잡 | O(n) |
| SECDED | 복잡 | 복잡 | O(log n) |

## 7. 적용 분야 비교

### 7.1 적용 기준

```
┌─────────────────────────────────────────────┐
│           오류 특성 파악                     │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│    단일 비트 오류 위주?                      │
│    ├─ 예 → 패리티 / 해밍 / SECDED           │
│    └─ 아니오 → CRC                          │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│    정정이 필요한가?                          │
│    ├─ 예 → 해밍 / SECDED                    │
│    └─ 아니오 → 패리티 / CRC                 │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│    고신뢰성 요구?                            │
│    ├─ 예 → SECDED                           │
│    └─ 아니오 → 해밍                         │
└─────────────────────────────────────────────┘
```

### 7.2 실제 적용 사례

| 방식 | 적용 분야 | 구체적 예시 |
|------|----------|------------|
| 패리티 비트 | 단순 통신 | 시리얼 통신, 키보드 |
| 2차원 패리티 | 데이터 전송 | RAID-2, 팩시밀리 |
| 해밍 코드 | 메모리 시스템 | DRAM, 플래시 메모리 |
| CRC | 네트워크 | 이더넷, Wi-Fi, TCP/IP |
| SECDED | 고신뢰 시스템 | 서버 ECC 메모리, 우주선 |

## 8. 장단점 분석

### 8.1 종합 비교

| 방식 | 장점 | 단점 |
|------|------|------|
| **패리티** | • 구현 최단순<br>• 오버헤드 최소<br>• 속도 빠름 | • 정정 불가<br>• 짝수 개 오류 검출 실패 |
| **2차원 패리티** | • 위치 식별 가능<br>• 단일 비트 정정<br>• 버스트 오류 강함 | • 오버헤드 큼<br>• 구현 복잡 |
| **해밍 코드** | • 단일 비트 정정<br>• 효율적 오버헤드<br>• 실시간 처리 | • 다중 비트 정정 불가<br>• 복잡한 설계 |
| **CRC** | • 버스트 오류 강함<br>• 하드웨어 효율<br>• 표준화됨 | • 정정 불가<br>• 재전송 필요 |
| **SECDED** | • 2비트 검출<br>• 높은 신뢰성<br>• 산업 표준 | • 높은 오버헤드<br>• 구현 복잡 |

## 9. 기술사적 판단

### 9.1 선정 기준

```
┌────────────────────────────────────────────────────┐
│                시스템 요구사항 분석                 │
└───────────────────────┬────────────────────────────┘
                        ↓
    ┌───────────────────┴───────────────────┐
    ↓                                       ↓
┌───────────┐                        ┌───────────┐
│ 오류율    │                        │ 대역폭    │
│ • 낮음    │                        │ • 제한    │
│ • 높음    │                        │ • 충분    │
└─────┬─────┘                        └─────┬─────┘
      ↓                                    ↓
┌─────────────────────────────────────────────────┐
│              신뢰성 vs 효율성 트레이드오프        │
└─────────────────────────────────────────────────┘
```

### 9.2 현업 적용 가이드라인

#### 시스템 유형별 권장 사항

| 시스템 유형 | 권장 방식 | 이유 |
|------------|----------|------|
| IoT 센서 | 패리티 | 저비용, 단순성 |
| 실시간 제어 | 해밍 | 지연 최소화, 정정 필요 |
| 네트워크 장비 | CRC | 버스트 오류, 표준 준수 |
| 금융 서버 | SECDED | 최고 신뢰성 요구 |
| 스토리지 | 2차원 패리티 + CRC | 다층 보호 |

### 9.3 비용-효과 분석

```
비용 (구현 복잡도)
   ↑
   │                          ★ SECDED
   │                    ★ 2차원 패리티
   │              ★ 해밍
   │        ★ CRC
   │  ★ 패리티
   └─────────────────────────────────→
           신뢰성 (오류 처리 능력)
```

## 10. 미래 전망

### 10.1 기술 발전 트렌드

| 분야 | 현재 | 미래 방향 |
|------|------|----------|
| 양자 컴퓨팅 | 표면 코드 연구 | 양자 오류 정정 (QEC) |
| AI/ML | 전통적 코드 | 머신러닝 기반 오류 예측 |
| 5G/6G | LDPC, Polar 코드 | 더 높은 효율 코드 |
| DNA 저장 | Reed-Solomon | 바이오 호환 코드 |

### 10.2 차세대 기술

#### LDPC (Low-Density Parity-Check) 코드
- 5G, Wi-Fi 6, DVB-S2 표준
- Shannon 한계에 근접 성능
- 병렬 처리 가능

#### Polar 코드
- 5G 제어 채널 표준
- 최초로 Shannon 한계 달성 증명
- 구조적 인코딩

#### 양자 오류 정정
```
┌─────────────────────────────────────┐
│     양자 비트 (Qubit) 오류 정정      │
├─────────────────────────────────────┤
│ • 표면 코드 (Surface Code)          │
│ • 색상 코드 (Color Code)            │
│ • 위상 오류 + 비트 플립 동시 처리    │
└─────────────────────────────────────┘
```

### 10.3 융합 기술

```
전통적 코드 ──────► 하이브리드 접근
    │                   │
    │                   ├── 다중 레이어 보호
    │                   ├── 적응적 코드 선택
    │                   └── AI 기반 동적 최적화
    │
    └───────► 새로운 응용
              ├── DNA 데이터 저장
              ├── 뇌-컴퓨터 인터페이스
              └── 양자 통신
```

## 11. 결론

### 11.1 핵심 요약

| 요구사항 | 최적 솔루션 |
|----------|------------|
| 최저 비용 | 패리티 비트 |
| 네트워크 표준 | CRC |
| 실시간 정정 | 해밍 코드 |
| 최고 신뢰성 | SECDED |
| 버스트 오류 | CRC, 2차원 패리티 |

### 11.2 의사결정 매트릭스

```
신뢰성 요구도
     ↑
     │                         ┌─────────┐
높음 │                    ┌───►│ SECDED  │
     │              ┌─────┤    └─────────┘
     │        ┌─────┤     │    ┌─────────┐
     │  ┌─────┤     │     └───►│  해밍   │
     │  │     │     │          └─────────┘
     │  │     │     │          ┌─────────┐
     │  │     │     └─────────►│  CRC    │
중간 │  │     │                └─────────┘
     │  │     │                ┌─────────┐
     │  │     └───────────────►│ 2차원   │
     │  │                      └─────────┘
     │  │                      ┌─────────┐
     │  └─────────────────────►│ 패리티  │
낮음 │                         └─────────┘
     └────────────────────────────────────→
         낮음        중간        높음
                대역폭 여유
```

---

## 🧒 어린이를 위한 설명

### 비유: 편지에 있는 오타 찾기

친구에게 편지를 쓰는데, 배달 도중에 글자가 지워지거나 바뀔 수 있다고 생각해 보세요!

#### 🎯 패리티 비트 = 글자 수 세기
```
"안녕하세요" → 글자가 5개야!

편지 받은 친구: "글자가 4개네? 뭔가 사라졌어!"
```
- 장점: 아주 쉽고 빠름
- 단점: 어디가 틀렸는지는 모름

#### 🧩 2차원 패리티 = 가로세로 낱말퍼즐
```
     ↓열 검사
안 → 녕 → 해  ✓
요 → 세 → 요  ✗ (이 줄에 문제 있어!)
     ↑
   행 검사
```
- 장점: 어디가 틀렸는지 찾을 수 있음
- 단점: 검사 칸이 많이 필요함

#### 🔢 해밍 코드 = 비밀번호 힌트
```
각 숫자마다 "이 숫자들이 이상하면 3번째 자리를 의심해!"

[1] [2] [3] [4] [5] [6] [7]
         ↑
      여기가 틀렸대!
```
- 장점: 정확히 어디가 틀렸는지 알려줌
- 단점: 힌트 숫자가 좀 필요함

#### 🔄 CRC = 특별한 도장 찍기
```
편지 내용 → 특별한 계산 → 도장 "A3F2"

받는 사람이 다시 계산해서 도장이 다르면?
→ "배달 중에 뭔가 바뀌었어!"
```
- 장점: 긴 편지도 한 번에 검사
- 단점: 어디가 틀렸는지는 모름 (다시 보내달라고 해야 함)

#### 🛡️ SECDED = 안전장치가 달린 금고
```
해밍 코드 + 하나 더!

틀린 글자 1개 → "내가 고쳐줄게!"
틀린 글자 2개 → "두 개가 틀렸어! 다시 보내!"
```
- 장점: 가장 안전함
- 단점: 비용이 제일 많이 듦

### 언제 뭘 쓸까?

| 상황 | 추천 방식 |
|------|----------|
| 카톡 보내기 | CRC (빠르고 효율적) |
| 은행 거래 | SECDED (돈이니까 완벽하게!) |
| 게임 데이터 | 해밍 코드 (끊김 없이) |
| 온도계 데이터 | 패리티 (단순해서) |

### 기억할 핵심! 💡

> **"빠르고 싼 건 패리티, 튼튼한 건 SECDED, 네트워크는 CRC!"**

---

## 📚 참고문헌

1. Hamming, R. W. (1950). "Error Detecting and Error Correcting Codes". Bell System Technical Journal.
2. Peterson, W. W., & Brown, D. T. (1961). "Cyclic Codes for Error Detection". Proceedings of the IRE.
3. Lin, S., & Costello, D. J. (2004). "Error Control Coding". Pearson Education.
4. IEEE 802.3 Ethernet Standard
5. JEDEC DDR5 Specification
