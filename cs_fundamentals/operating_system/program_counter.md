---
layout: note
title: 프로그램 카운터 (Program Counter, PC)
---

# 프로그램 카운터 (Program Counter, PC)

## 어린이를 위한 전체 내용 종합 인사이트 핵심 설명

프로그램 카운터는 **"책갈피"** 같은 역할을 합니다. 책을 읽을 때 어디까지 읽었는지 표시해두는 책갈피처럼, CPU가 프로그램을 실행할 때 **"다음에 실행할 명령어가 메모리 어디에 있는지"**를 기억하는 특별한 저장 공간입니다.

---

## 1. 개념

**프로그램 카운터(Program Counter, PC)**는 CPU 내부의 **특수 목적 레지스터(Special Purpose Register)**로, **다음에 실행할 명령어(Instruction)의 메모리 주소**를 저장하는 레지스터입니다.

- 명령어 포인터(Instruction Pointer, IP)라고도 불립니다
- CPU가 순차적으로 프로그램을 실행할 수 있도록 **현재 실행 위치를 추적**합니다

## 2. 등장 배경

### 폰노이만 구조의 명령어 실행 사이클
컴퓨터는 메모리에 저장된 프로그램을 **순차적으로 실행**합니다. 이때 CPU는 다음 두 가지를 알아야 합니다:

1. **현재 실행할 명령어**는 무엇인가?
2. **다음 명령어**는 메모리 어디에 있는가?

→ 이 **"다음 명령어의 위치"**를 기억하기 위해 프로그램 카운터가 등장했습니다

## 3. 구성 요소

| 구성 요소 | 설명 |
|----------|------|
| **레지스터 비트 폭** | 주소 버스 크기와 동일 (32bit CPU → 32bit PC, 64bit CPU → 64bit PC) |
| **자동 증가 기능** | 명령어 실행 후 자동으로 다음 주소를 가리키도록 증가 |
| **분기 제어 입력** | 점프(Jump), 호출(Call) 명령어 시 새 주소로 갱신 |

## 4. 핵심 원리

### 명령어 실행 사이클 (Instruction Cycle)

```
┌─────────────────────────────────────────┐
│           명령어 실행 사이클             │
├─────────────────────────────────────────┤
│  1. Fetch (인출)                        │
│     PC가 가리키는 주소에서 명령어 읽기   │
│                   ↓                     │
│  2. Decode (해석)                       │
│     명령어의 의미 파악                   │
│                   ↓                     │
│  3. Execute (실행)                      │
│     명령어 수행                          │
│                   ↓                     │
│  4. PC 갱신                             │
│     - 순차 실행: PC = PC + 명령어길이   │
│     - 분기 실행: PC = 새로운주소        │
└─────────────────────────────────────────┘
```

### PC 값의 변화 예시
```
주소    명령어
0x1000  LOAD  R1, [0x2000]   ← PC = 0x1000 (실행)
0x1004  ADD   R1, R2         ← PC = 0x1004 (다음)
0x1008  JUMP  0x2000         ← PC = 0x1008 (실행 후 PC = 0x2000으로 변경)
```

## 5. 장단점

| 장점 | 단점/한계 |
|-----|----------|
| **순차 실행 보장**: 프로그램의 논리적 흐름 유지 | **분기 예측 필요**: 조건문/반복문 시 성능 저하 가능 |
| **단순한 구조**: 하드웨어 구현이 간단 | **단일 스레드**: 하나의 PC는 하나의 실행 흐름만 추적 |
| **빠른 접근**: CPU 내부 레지스터로 즉시 접근 | **컨텍스트 스위칭 비용**: 멀티태스킹 시 PC 저장/복원 필요 |

## 6. 비교

| 구분 | 프로그램 카운터 (PC) | 스택 포인터 (SP) |
|------|---------------------|------------------|
| **목적** | 다음 실행할 명령어 주소 | 현재 스택 최상단 주소 |
| **변경 시점** | 매 명령어 실행마다 | 함수 호출/반환, 지역변수 할당 시 |
| **증감 방향** | 주로 증가 (순차 실행) | 감소 (스택은 아래로 성장) |
| **용도** | 제어 흐름 관리 | 데이터/복귀 주소 관리 |

## 7. 기술사적 판단

### 현업 관점에서의 중요성

1. **디버깅의 핵심**: 프로그램 크래시 발생 시 PC 값으로 **정확한 충돌 지점** 파악
2. **성능 최적화**: 분기 예측(Branch Prediction) 실패 시 PC 갱신으로 인한 **파이프라인 플러시** 비용 고려
3. **컨텍스트 스위칭**: 멀티태스킹 구현을 위해 각 프로세스/스레드마다 **PC 값을 별도 저장** 필요
4. **보안**: 버퍼 오버플로우 공격 시 **반환 주소(PC 영향)** 변조 방어 중요

### 파이프라인과 PC
```
단일 사이클:  PC → Fetch → Decode → Execute (순차)
파이프라인:   PC1 → Fetch1 → Decode1 → Execute1
              PC2 → Fetch2 → Decode2 → Execute2
              (병렬 처리로 성능 향상, but 분기 시 스톨 발생)
```

## 8. 미래 전망

| 분야 | 발전 방향 |
|------|----------|
| **이종 코어** | 빅리틀 아키텍처에서 각 코어별 PC 관리 복잡도 증가 |
| **AI 가속기** | 데이터플로우 기반 처리로 PC 개념 약화 (비폰노이만 구조) |
| **양자 컴퓨팅** | 순차 실행 모델 자체가 달라져 PC 개념 재정의 필요 |
