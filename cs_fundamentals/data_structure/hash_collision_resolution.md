# 해시 충돌 해결 방법 (Hash Collision Resolution)

## I. 데이터 무결성과 효율적 저장을 위한 해시 충돌 해결의 개요

### 1.1 해시 충돌(Hash Collision)의 정의
- **해시 충돌(Hash Collision)**이란 서로 다른 두 개 이상의 키(Key)가 해시 함수(Hash Function)에 의해 동일한 해시 값(Hash Value) 또는 인덱스(Index)로 매핑되는 현상을 의미합니다.
- 비둘기집 원리(Pigeonhole Principle)에 의해 해시 테이블의 크기보다 키의 개수가 많으면 반드시 발생하며, 테이블 크기가 크더라도 확률적으로 매우 빈번하게 발생합니다. 상세 원리는 [생일 역설(Birthday Paradox)](../algorithm/birthday_paradox.md) 문서를 참조하십시오.

### 1.2 충돌 해결의 필요성
- **데이터 무결성 보장**: 충돌 발생 시 기존 데이터를 덮어쓰지 않고 새로운 수용 공간을 확보해야 합니다.
- **탐색 성능 유지**: 효율적인 해결 방안이 없을 경우 탐색 복잡도가 $O(1)$에서 $O(N)$으로 최악의 성능을 보일 수 있습니다.
- **공간 효율성**: 한정된 메모리 자원 내에서 적재율(Load Factor)을 최적화하기 위함입니다.

---

## II. 해시 충돌 해결 방법의 체계적 분류

해시 충돌 해결 방법은 크게 데이터를 테이블 외부에 저장하느냐, 내부의 다른 빈 슬롯을 찾느냐에 따라 분류됩니다.

| 구분 | 개방 주소법 (Open Addressing) | 분리 체이닝 (Separate Chaining) |
| :--- | :--- | :--- |
| **기본 원리** | 충돌 발생 시 테이블 내 다른 빈 슬롯을 탐색 | 충돌 발생 시 해당 버킷에 연결 리스트 등으로 연결 |
| **저장 위치** | 해시 테이블 내부 (Closed Hashing) | 해시 테이블 외부 공간 추가 활용 (Open Hashing) |
| **적재율($\alpha$)** | $\alpha \le 1$ 유지 필수 (성능 급감 방지) | $\alpha > 1$ 가능 (유연한 확장성) |
| **삭제 연산** | 삭제된 노드 처리가 복합함 (Dummy Node 필요) | 연결 리스트의 노드 삭제로 비교적 간단 |
| **주요 기법** | Linear/Quadratic Probing, Double Hashing | Linked List, Red-Black Tree (Java 8+) |

---

## III. 핵심 충돌 해결 기법 상세 설명

### 3.1 개방 주소법 (Open Addressing)
충돌이 발생하면 정해진 규칙(Probing)에 따라 테이블의 다른 빈 공간을 찾는 방식입니다.

1.  **선형 조사 (Linear Probing)**:
    - 규칙: $h(k, i) = (h'(k) + i) \mod m$
    - 특징: 충돌 시 바로 다음 인덱스를 확인. 구현이 단순하고 캐시 적중률(Cache Hit Rate)이 높음.
    - 단점: 데이터가 특정 영역에 뭉치는 **1차 군집화(Primary Clustering)** 현상 발생.
2.  **이차 조사 (Quadratic Probing)**:
    - 규칙: $h(k, i) = (h'(k) + c_1i + c_2i^2) \mod m$
    - 특징: 보정치를 제곱수로 더해 조사 간격을 넓힘. 1차 군집화 완화.
    - 단점: 동일한 초기 해시값을 가지면 같은 경로를 조사하는 **2차 군집화(Secondary Clustering)** 발생.
3.  **이중 해싱 (Double Hashing)**:
    - 규칙: $h(k, i) = (h_1(k) + i \cdot h_2(k)) \mod m$
    - 특징: 두 번째 해시 함수로 조사 간격을 결정. 군집화 문제를 가장 효과적으로 해결.
    - 단점: 연산 부담이 다소 높음.

### 3.2 분리 체이닝 (Separate Chaining)
각 버킷을 데이터 구조(주로 연결 리스트)의 헤드로 사용하여 여러 데이터를 수용하는 방식입니다.

- **연결 리스트 (Linked List)**: 가장 보편적인 방법으로 구현이 간단합니다.
- **트리 (Tree)**: 데이터 개수가 많아질 경우(예: Java 8 HashMap), 탐색 성능 향상을 위해 연결 리스트 대신 **레드-블랙 트리(Red-Black Tree)**를 사용하여 $O(\log N)$ 성능을 보장합니다.

---

## IV. 특수 및 고급 충돌 해결 기법

| 기법 명칭 | 설명 | 장점 |
| :--- | :--- | :--- |
| **뻐꾸기 해싱 (Cuckoo Hashing)** | 두 개의 해시 함수와 테이블을 사용하여 둥지를 뺏는 방식 | 최악의 경우에도 $O(1)$ 탐색 시간 보장 |
| **로빈 후드 해싱 (Robin Hood Hashing)** | 충돌 시 원래 위치에서 더 멀리 떨어진 노드에게 자리를 양보 | 검색 거리의 분산을 줄여 전체 성능 균일화 |
| **재해싱 (Rehashing)** | 테이블이 일정 수준(임계치) 이상 차면 크기를 늘리고 재배치 | 장기적 성능 유지, 적재율 관리의 핵심 |

---

## V. 기술사적 판단 및 향후 전망

### 5.1 기술사적 판단 (Professional Engineer's Insight)
- **적재율(Load Factor) 매니지먼트**: 어떤 알고리즘을 선택하든 적재율이 0.7~0.8을 넘어가면 성능이 지수적으로 하향합니다. 따라서 시스템 설계 시 **동적 리사이징(Dynamic Resizing)** 전략이 반드시 병행되어야 합니다.
- **데이터 특성 기반 선택**: 단순 정수 키의 경우 캐시 효율이 좋은 선형 조사가 유리할 수 있으나, 가변적인 문자열 키나 대규모 데이터셋에서는 체이닝이나 이중 해싱이 안정적입니다.
- **삭제 연산의 중요성**: Open Addressing은 삭제 시 '사용 중이었음'을 표시하는 마커가 필요하며, 이 마커가 누적되면 성능이 저하되므로 환경에 따른 주의가 필요합니다.

### 5.2 향후 전망
- **보안 해싱 (Security-Aware Hashing)**: Hash DoS 공격(충돌을 의도적으로 유발하여 서버 마비)에 대비하여 분산 엔진 등에서 무작위 시드(Random Seed)를 적용한 해시 함수 채택이 필수화되고 있습니다.
- **비휘발성 메모리(NVM) 최적화**: 인메모리 DB의 확산에 따라 캐시 라인(Cache Line)을 고려한 해싱 구조와 일관된 해싱(Consistent Hashing)의 결합이 분산 아키텍처의 핵심 기술로 자리 잡을 것입니다.

---

## [부록] 쉽게 이해하는 해시 충돌 (주차장 비유)

### 🚗 "만차인 주차장에서 내 자리 찾기" 비유

주차장에 도착했는데, 내 번호표에 적힌 칸에 이미 다른 차가 주차되어 있다면 어떻게 해야 할까요?

1.  **상황**: 주차장 칸 번호는 해시 함수가 알려준 주소예요. 그런데 이미 그 칸에 차가 있네요! 이것이 바로 **충돌(Collision)**입니다.
2.  **개방 주소법 (옆 칸 찾아보기)**:
    - "아, 내 칸에 차가 있네? 그럼 바로 옆 칸(선형 조사)이나 조금 떨어진 빈칸(이차 조사)을 찾아봐야지."
    - 주차장 안에서 어떻게든 빈 곳을 찾아내는 방식이에요.
3.  **분리 체이닝 (2층 주차장/기계식 주차장)**:
    - "내 칸에 차가 있어? 그럼 그 칸 밑으로 기계식 주차 엘리베이터를 달아서 한 칸에 여러 대를 층층이(연결 리스트) 쌓아두자."
    - 주차장 칸 하나를 입구로 쓰고, 그 뒤로 줄줄이 차를 연결하는 방식이에요.
4.  **로빈 후드 해싱 (착한 주차)**:
    - "내가 주차장을 한참 헤매서 힘들게 찾았는데, 저 차는 금방 찾았네? 내가 더 고생했으니까 저 차를 밀어내고 내가 여기 주차할래! (고생을 나눠 가지자)"

### 🌟 핵심 포인트!
- **충돌은 나쁜 게 아니라, 맛집에 줄이 길게 늘어선 것처럼 자연스러운 현상이에요.**
- 중요한 건 **"줄을 어떻게 효율적으로 세울 것인가"** 하는 방법이랍니다!

**💡 한 줄 요약**: "똑같은 번호표를 가진 데이터들이 싸우지 않게 빈자리를 찾아주거나 줄을 세워주는 교통정리 기술!"
