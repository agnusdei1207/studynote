# 해싱 (Hashing)

## I. 데이터 관리의 혁신, 해싱(Hashing)의 개요

### 1.1 정의
- **해싱(Hashing)**은 임의의 길이를 가진 데이터를 고정된 길이의 고유한 수치(해시 값)로 변환하여, 데이터를 저장하거나 검색하는 시간을 $O(1)$로 단축시키는 탐색 최적화 기술입니다.
- **해시 함수(Hash Function)**를 통해 키(Key)를 주소(Address)로 직접 매핑하여 데이터의 위치를 즉시 찾아냅니다.

### 1.2 등장 배경
- **탐색 효율의 극대화**: 이진 탐색($O(\log N)$)보다 빠른 상수 시간 탐색의 필요성 대두.
- **데이터 보안 및 무결성**: 데이터의 지문(Digital Fingerprint)을 생성하여 위변조를 감지하고 암호화에 활용.

---

## II. 해싱의 코어 구성요소 및 핵심 원리

### 2.1 3대 구성요소
| 구성요소 | 설명 | 비고 |
| :--- | :--- | :--- |
| **해시 키 (Hash Key)** | 변환하고자 하는 원본 데이터 | 문자열, 숫자 등 |
| **해시 함수 (Hash Function)** | 키를 특정 범위의 정수값(해시 코드)으로 바꾸는 함수 | 산술 연산, 비트 연산 등 |
| **해시 테이블 (Hash Table)** | 해시 값을 인덱스로 하여 실제 데이터를 저장하는 공간 | 버킷(Bucket)과 슬롯(Slot)으로 구성 |

### 2.2 핵심 메커니즘: 매핑(Mapping)과 버킷(Bucket)
- **과정**: `Key` → `Hash Function` → `Hash Code` → `Index` → `Data Storage`
- **부하율 (Load Factor)**: $\alpha = \frac{n}{m}$ ($n$: 저장된 키 개수, $m$: 테이블 크기). 이 값이 커질수록 성능이 저하되므로 적절한 리사이징(Resizing)이 필요합니다.

---

## III. 해싱의 최대 난제: 충돌(Collision) 해결 전략

동일한 해시 값이 발생하는 **해시 충돌(Hash Collision)**을 해결하는 것이 알고리즘 설계의 핵심입니다. 상세한 해결 방법은 [해시 충돌 해결 방법 상세](./hash_collision_resolution.md) 문서를 참조하십시오.

### 3.1 충돌 해결 전략 비교

| 구분 | 체이닝 (Chaining) | 개방 주소법 (Open Addressing) |
| :--- | :--- | :--- |
| **영문 명칭** | **Separate Chaining** | **Open Addressing** |
| **기본 원리** | 충돌 발생 시 연결 리스트(Linked List)로 연결 | 테이블 내의 다른 빈 공간을 찾아 저장 |
| **공간 효율** | 테이블 외부에 추가 공간 필요 | 테이블 내부 공간만 사용 |
| **탐색 성능** | 데이터가 많아지면 리스트가 길어져 성능 저하 | 해시 테이블의 밀도가 높으면 성능 급격히 저하 |
| **대표 기법** | LinkedList 활용 | 선형 조사, 이차 조사, 이중 해싱 |

### 3.2 개방 주소법(Open Addressing)의 세부 기법
1. **선형 조사 (Linear Probing)**: 충돌 시 $i+1, i+2$ 순으로 다음 빈칸 탐색 (군집화 문제 발생).
2. **이차 조사 (Quadratic Probing)**: $i+1^2, i+2^2$ 순으로 탐색하여 군집화 완화.
3. **이중 해싱 (Double Hashing)**: 두 번째 해시 함수를 사용하여 조사 간격을 결정.

---

## IV. 주요 해시 알고리즘 및 비교 분석

### 4.1 용도별 해시 함수 분류
| 분류 | 알고리즘 명칭 | 주요 특징 |
| :--- | :--- | :--- |
| **비암호화 해시** | MurmurHash, CityHash | 속도가 매우 빠름, 해시 테이블용 |
| **암호화 해시** | SHA-256, SHA-3 | 단방향성, 충돌 저항성, 보안 및 무결성용 |
| **오류 검출** | CRC32 | 데이터 전송 시 변조/손실 확인용 |

---

## V. 기술사적 판단 및 향후 전망

### 5.1 기술사적 판단 (Professional Engineer's Insight)
- **완벽한 해시 함수는 존재하지 않음**: 충돌은 반드시 발생한다는 전제하에 시스템 특성에 맞는 **충돌 해결 기법 선택**과 **적절한 해시 테이블 크기 유지**가 시스템 성능의 핵심입니다.
- **보안성 고려**: 사용자 비밀번호 등 보안 데이터 저장 시에는 단순 해싱이 아닌 **솔팅(Salting)** 및 **키 스트레칭(Key Stretching)**을 적용하여 레인보우 테이블 공격에 대비해야 합니다.

### 5.2 향후 전망
- **대규모 실시간 데이터**: 빅데이터 환경에서 효율적인 분산 저장을 위해 **일관된 해싱 (Consistent Hashing)** 기술이 클라우드 서비스(카산드라, 메모리 캐시 등)에서 더욱 중요해질 전망입니다.
- **하드웨어 가속**: 데이터 센터의 폭증하는 트래픽 처리를 위해 전용 하드웨어(FPGA/ASIC) 기반의 초고속 해싱 솔루션 도입이 확대될 것입니다.

---

## [부록] 쉽게 이해하는 해싱 (우체국 정리함 비유)

### 📮 "우체국 아저씨의 마법 이름표" 비유

여러분, 전국에서 오는 엄청나게 많은 편지를 어떻게 한 번에 찾을 수 있을까요?

1. **상황**: 우체국에 수만 장의 편지가 쌓여 있어요. 하나하나 이름을 읽으며 찾으려면 하루 종일 걸리겠죠?
2. **해시 함수 (마법 이름표)**: 우체국 아저씨는 특별한 규칙을 만들었어요. "이름의 첫 글자가 '가'면 1번 상자, '나'면 2번 상자에 넣자!"
   - 여기서 '이름'은 **키(Key)**이고, '첫 글자 규칙'은 **해시 함수(Hash Function)**예요.
3. **해시 테이블 (상자들)**: 번호가 적힌 상자들이 **해시 테이블(Hash Table)**이에요. 아저씨는 이제 이름만 보고 바로 상자 번호를 알아서 편지를 슥 집어넣거나 뺄 수 있죠!
4. **충돌 해결 (상자가 꽉 찼을 때)**:
   - **체이닝**: "1번 상자에 편지가 여러 장이면, 그냥 봉투끼리 클립으로 집어서 줄줄이 연결해두자!"
   - **개방 주소법**: "1번 상자가 꽉 찼어? 그럼 바로 옆에 있는 2번 상자가 비었는지 볼까?"

### 🌟 핵심 포인트!
- **"복잡한 이름(데이터)을 간단한 번호(주소)로 바꿔서 빛의 속도로 찾는 기술!"**
- 이 기술 덕분에 우리가 인터넷에 아이디를 입력하자마자 로그인이 되는 거랍니다!

**💡 한 줄 요약**: "데이터에게 짧은 별명을 붙여서 전용 보관함에 딱 넣어두는 정리 정돈의 끝판왕!"
