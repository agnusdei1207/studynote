---
layout: default
title: 패리티 비트
---

# 패리티 비트

## 1. 개념

### 1.1 정의

**패리티 비트(Parity Bit)**는 디지털 데이터 전송 및 저장 시 **오류를 탐지(Error Detection)**하기 위해 추가하는 비트입니다. 데이터의 '1'의 개수가 항상 짝수 또는 홀수가 되도록 조정하는 가장 간단한 오류 탐지 방식입니다.

### 1.2 기본 원리

```
┌─────────────────────────────────────────────────────────────┐
│                    패리티 비트 동작 원리                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  7비트 데이터:  1 0 1 1 0 0 1  (1의 개수 = 4개, 짝수)        │
│                    ↓                                        │
│  짝수 패리티:  1 0 1 1 0 0 1 [0]  → 전체 1의 개수 = 4 (짝수) │
│  홀수 패리티:  1 0 1 1 0 0 1 [1]  → 전체 1의 개수 = 5 (홀수) │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2. 등장 배경

### 2.1 역사적 배경

| 시기 | 사건 | 의의 |
|-----|------|------|
| 1940년대 후반 | 초기 컴퓨터(UNIVAC I)에서 신뢰성 문제 대응 | 최초의 오류 탐지 코드 상용화 |
| 1950년대 | 리처드 해밍(Richard Hamming)의 해밍 코드 연구 | 패리티 비트의 한계 극복 시도 |
| 1960-70년대 | 통신 시스템 표준화(RS-232 등) | 패리티 비트의 통신표준 채택 |
| 1980년대 이후 | 메모리 시스템에서 ECC(ECC Memory) 발전 | 패리티에서 SECDED로 진화 |

### 2.2 기술적 필요성

**1) 초기 디지털 시스템의 신뢰성 문제**
- 진공관, 릴레이의 잦은 고장
- 잡음에 취약한 초기 통신 회로
- 데이터 무결성 보장의 필요성

**2) 비용 효율적인 오류 탐지**
- 최소한의 하드웨어 오버헤드 (1비트 추가)
- 단순한 XOR 회로로 구현 가능
- 실시간 오류 탐지 용이

## 3. 구성 요소

### 3.1 패리티 비트의 종류

| 종류 | 정의 | 1의 개수 특성 | 패리티 비트 값 |
|-----|------|-------------|---------------|
| **짝수 패리티(Even Parity)** | 전체 1의 개수가 짝수가 되도록 | 짝수 | 데이터의 1이 홀수개면 1, 짝수개면 0 |
| **홀수 패리티(Odd Parity)** | 전체 1의 개수가 홀수가 되도록 | 홀수 | 데이터의 1이 짝수개면 1, 홀수개면 0 |

### 3.2 패리티 비트 계산 회로

```
           ┌───────────────────────────────────────┐
           │         패리티 비트 생성 회로           │
           ├───────────────────────────────────────┤
           │                                       │
  데이터 ───┬── D0 ──┐                             │
           ├── D1 ──┼──┐                          │
           ├── D2 ──┼──┼──┐                       │
           ├── D3 ──┼──┼──┼──┐                    │
           │        │  │  │  │                    │
           │        └──┴──┴──┴── [XOR 회로들]       │
           │                      ↓               │
           │                  패리티 비트 (P)        │
           │                                       │
           └───────────────────────────────────────┘
```

**논리식**: n비트 데이터 D₀~Dₙ₋₁에 대해 짝수 패리티 비트 P는

$$P = D_0 \oplus D_1 \oplus D_2 \oplus \cdots \oplus D_{n-1}$$

### 3.3 전송 시스템 구조

```
┌──────────────────────────────────────────────────────────────────┐
│                     패리티 비트 기반 전송 시스템                     │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [송신측]                    [수신측]                            │
│                                                                  │
│  데이터 ──┐              ┌──→ 데이터                               │
│         [패리티 생성기]     │     ↓                                │
│          ↓               │   분리기                                │
│  패리티 ──┴──[통신로]───→  └──→ 패리티 ──[패리티 검사기]──→ 오류/정상 │
│                                       ↓                            │
│                                   (일치 여부 확인)                  │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

## 4. 핵심 원리

### 4.1 패리티 비트 생성 과정

**예시: 7비트 데이터 "1011001"의 패리티 비트 생성**

| 단계 | 데이터 | 1의 개수 | 패리티 비트 |
|-----|--------|---------|-----------|
| 원본 데이터 | 1 0 1 1 0 0 1 | 4개 (짝수) | - |
| 짝수 패리티 추가 | 1 0 1 1 0 0 1 **[0]** | 4개 (짝수) | 0 |
| 홀수 패리티 추가 | 1 0 1 1 0 0 1 **[1]** | 5개 (홀수) | 1 |

### 4.2 패리티 검사 과정

```
[수신측 검사 과정]

수신된 데이터 + 패리티: 1 0 1 1 0 0 1 0
                        ↓
              전체 비트의 1 개수 카운트
                        ↓
                ┌────────┴────────┐
                ↓                 ↓
            짝수 패리티 모드    홀수 패리티 모드
            1의 개수가 짝수?    1의 개수가 홀수?
                ↓                 ↓
           YES: 정상         YES: 정상
           NO:  오류          NO:  오류
```

### 4.3 수학적 표현

**패리티 체크 함수 f(x₁, x₂, ..., xₙ):**

$$f(x_1, x_2, \ldots, x_n) = \left(\sum_{i=1}^{n} x_i\right) \bmod 2$$

- **짝수 패리티 정상**: $f(data) \oplus P = 0$
- **홀수 패리티 정상**: $f(data) \oplus P = 1$

### 4.4 다양한 데이터 길이에서의 패리티 계산

| 데이터 길이 | 데이터 (2진수) | 1의 개수 | 짝수 패리티 | 홀수 패리티 |
|-----------|---------------|---------|-----------|-----------|
| 4비트 | 1101 | 3 | 1 | 0 |
| 8비트 | 10110010 | 4 | 0 | 1 |
| 16비트 | 1101010110110101 | 9 | 1 | 0 |
| 32비트 | 01101011... (9개) | 9 | 1 | 0 |

## 5. 장단점

### 5.1 장점

| 장점 | 설명 |
|-----|------|
| **구현 단순** | XOR 게이트만으로 구현 가능, 하드웨어 오버헤드 최소 |
| **연산 속도** | 단일 클럭 사이클 내에 계산 완료 가능 |
| **비용 효율** | 1비트만 추가로 필요, 저장 공간 낭비 최소화 |
| **실시간 검사** | 데이터 전송 중 실시간 오류 탐지 가능 |
| **표준화** | RS-232, SCSI 등 다양한 표준에서 채택 |

### 5.2 단점

| 단점 | 설명 |
|-----|------|
| **단일 비트 오류만 탐지** | 2비트 오류 발생 시 탐지 불가 (취약점) |
| **오류 정정 불가** | 오류 위치 식별 불가, 재전송 필요 |
| **오류 탐지율** | 임의의 오류에 대해 50% 탐지율 (한계) |
| **오버헤드** | 1비트 추가로 약 1/(n+1)의 전송 효율 저하 |
| **버스트 오류 취약** | 연속된 비트 오류 발생 시 탐지 실패 가능 |

### 5.3 오류 탐지 한계 시나리오

```
[2비트 오류 탐지 실패 예시]

원본:     1 0 1 1 0 0 1 [0]  (짝수 패리티, 1의 개수 = 4)
오류 발생: 1 0 1 1 0 0 1 [0]
               ↑       ↑
              비트 반전 (두 개)
결과:      0 0 1 0 0 0 1 [0]  (여전히 짝수, 1의 개수 = 2)
                              → 오류 탐지 실패!
```

## 6. 비교

### 6.1 다른 오류 탐지/정정 방식과의 비교

| 방식 | 추가 비트수 | 오류 탐지 | 오류 정정 | 주요 용도 |
|-----|-----------|----------|----------|----------|
| **패리티 비트** | 1 | 단일 비트 | 불가 | 단순 시스템 |
| **2차원 패리티** | n+m | 단일/다중 버스트 | 일부 정정 가능 | 데이터 전송 |
| **해밍 코드** | r (2^r ≥ n+r+1) | 다중 비트 | 단일 비트 정정 | 메모리 시스템 |
| **CRC** | 8~32 | 버스트 오류 | 불가 | 네트워크 프로토콜 |
| **SECDED** | 2r | 2비트까지 | 단일 비트 정정 | 서버 메모리 |

### 6.2 짝수 패리티 vs 홀수 패리티

| 비교 항목 | 짝수 패리티 | 홀수 패리티 |
|----------|-----------|-----------|
| **정의** | 전체 1의 개수 = 짝수 | 전체 1의 개수 = 홀수 |
| **전송 중 ALL-0 방지** | 불가 (모든 0은 유효) | 가능 (모두 0이면 오류) |
| **일상 사용** | 더 일반적 | 특수 목적 |
| **논리 회로** | 동일 복잡도 | 동일 복잡도 |
| **표준 채택** | RS-232, PCI 등 | 일부 산업용 시스템 |

### 6.3 1차원 vs 2차원 패리티

```
[1차원 패리티]
D0 D1 D2 D3 [P0]

[2차원 패리티 (패리티 바이트)]
D0 D1 D2 D3 [P0]
D4 D5 D6 D7 [P1]
D8 D9 D10 D11 [P2]
[P3 P4 P5 P6] [P7]  ← 행/열 패리티 모두 확인
```

| 특성 | 1차원 패리티 | 2차원 패리티 |
|-----|------------|-------------|
| 구조 | 데이터당 1비트 | 행/열별 패리티 |
| 탐지 능력 | 단일 비트 | 다중 비트, 일부 버스트 |
| 오버헤드 | 낮음 | 높음 |
| 정정 능력 | 없음 | 단일 비트 정정 가능 |
| 응용 | 단순 시스템 | 데이터 링크, 저장 매체 |

## 7. 기술사적 판단

### 7.1 현업 활용 분석

**실제 적용 사례:**

| 분야 | 적용 예시 | 설계 고려사항 |
|-----|----------|-------------|
| **UART 통신** | RS-232, 시리얼 포트 | 비동기식 통신의 기본 오류 검사 |
| **메모리 시스템** | 구형 서버 메모리 | ECC 도입 전 단계, 현재는 폐기 |
| **SCSI/SATA** | 스토리지 인터페이스 | CRC와 병행 사용 |
| **PCI 버스** | 주변 장치 버스 | 주소/데이터 패리티 체크 |
| **플래시 메모리** | 일부 NOR 플래시 | 간단한 무결성 검사 |

### 7.2 설계 시 의사결정 기준

**1) 패리티 비트 사용이 적합한 경우:**
- 오류 발생 확률이 매우 낮은 환경
- 단순한 1비트 오류만 탐지하면 되는 경우
- 하드웨어 비용 제약이 큰 경우
- 재전송 요청(Retransmission)이 가능한 통신 환경

**2) 대안 사용이 적합한 경우:**
- 오류 정정이 필요한 경우 → 해밍 코드, SECDED
- 버스트 오류 탐지 필요 → CRC
- 대용량 데이터 무결성 → 체크섬, 해시

### 7.3 성능 분석

**오버헤드 분석:**

| 데이터 길이 | 패리티 비트 오버헤드 | 전송 효율 |
|-----------|-------------------|----------|
| 8비트 | 1/8 = 12.5% | 88.9% |
| 16비트 | 1/16 = 6.25% | 94.1% |
| 32비트 | 1/32 = 3.125% | 97.0% |
| 64비트 | 1/64 = 1.56% | 98.5% |

$$전송 효율 = \frac{n}{n+1}$$

### 7.4 현대적 구현

**하드웨어 설계 예시 (Verilog):**

```verilog
// 짝수 패리티 생성기
module parity_generator (
    input  [7:0] data_in,
    output reg    parity_bit
);

always @(*) begin
    parity_bit = ^data_in;  // XOR reduction 연산
end

endmodule

// 짝수 패리티 검사기
module parity_checker (
    input  [7:0] data_in,
    input        parity_bit,
    output reg   error_flag
);

wire [7:0] combined = {data_in, parity_bit};

always @(*) begin
    error_flag = ^combined;  // 1이면 오류, 0이면 정상
end

endmodule
```

**소프트웨어 구현 (C):**

```c
// 짝수 패리티 계산 함수
uint8_t calculate_parity(uint8_t data) {
    uint8_t parity = 0;
    while (data) {
        parity ^= (data & 1);  // LSB와 XOR
        data >>= 1;            // 우측 시프트
    }
    return parity;  // 1의 개수가 홀수면 1, 짝수면 0
}

// 검사 함수
bool check_parity(uint8_t data, uint8_t parity_bit) {
    return (calculate_parity(data) == parity_bit);
}
```

### 7.5 통계적 오류 탐지율

**BER(Bit Error Rate) 환경에서의 탐지율:**

| BER | 단일 비트 오류 확률 | 2비트 오류 확률 | 패리티 탐지율 |
|-----|-------------------|----------------|-------------|
| 10⁻⁶ | 8×10⁻⁶ | ~2.8×10⁻¹¹ | ~99.997% |
| 10⁻⁴ | 8×10⁻⁴ | ~2.8×10⁻⁷ | ~99.7% |
| 10⁻² | 8×10⁻² | ~2.8×10⁻³ | ~73% |

$$P(탐지실패) = \binom{n}{2} \times BER^2$$

## 8. 미래 전망

### 8.1 기술 발전 방향

| 기술 | 발전 내용 | 패리티 비트의 역할 |
|-----|----------|-----------------|
| **양자 컴퓨팅** | 양자 오류 정정 코드 연구 | 양자 비트의 안정성 확인 |
| **AI 가속기** | 신경망 추론 단순화 | 간단한 무결성 검사 |
| **저전력 IoT** | 에너지 하베스팅 시스템 | 최소 오버헤드 오류 탐지 |
| **엣지 컴퓨팅** | 분산 오류 탐지 | 로컬 1차 검사용 |

### 8.2 한계 극복을 위한 하이브리드 방식

```
[계층형 오류 관리]

+-----------------------------------------------+
|              애플리케이션 계층                  |
|           (암호화 해시, 디지털 서명)              |
+-----------------------------------------------+
|              전송 계층                         |
|              (CRC-32)                          |
+-----------------------------------------------+
|              데이터 링크 계층                   |
|              (2차원 패리티) ← 빠른 1차 검사      |
+-----------------------------------------------+
|              물리 계층                          |
|              (패리티 비트) ← 실시간 HW 검사      |
+-----------------------------------------------+
```

### 8.3 연구 주제

1. **적응형 패리티**: 채널 상태에 따라 패리티 비트 수 동적 조절
2. **확률적 패리티**: 중요도에 따른 선택적 패리티 적용
3. **머신러닝 기반 패리티 배치**: 오류 패턴 학습을 통한 최적 배치
4. **양자 패리티**: 양자 채널에서의 오류 탐지 방법론

### 8.4 산업별 전망

| 산업 | 현황 | 전망 |
|-----|------|------|
| **서버/스토리지** | ECC 메인스트림 | 패리티는 레거시 유지 |
| **임베디드 시스템** | 여전히 활용 | 비용 효율성으로 계속 사용 |
| **자동차** | ASIL 대응 | 더 강력한 코드로 전환 중 |
| **우주 항공** | 방사선 내성 | 다중 패리티 + 해밍 코드 병행 |

---

## 🧒 어린이를 위한 설명

### 숫자 맞추기 게임으로 이해하는 패리티 비트

**상황: 친구에게 숫자 카드를 보낼 때!** 📦

```
📮 내가 보내는 카드: 4장

┌─────┬─────┬─────┬─────┐
│  1  │  0  │  1  │  1  │
│ (●) │     │ (●) │ (●) │
└─────┴─────┴─────┴─────┘

동그라미(●)가 3개 있어요! (홀수)
```

**여기서 패리티 비트 = "점검 카드"!**

```
[짝수 패리티] 규칙: "동그라미가 항상 짝수가 되게 해!"

┌─────┬─────┬─────┬─────┬─────┐
│  1  │  0  │  1  │  1  │  1  │ ← 점검 카드 추가!
│ (●) │     │ (●) │ (●) │ (●) │
└─────┴─────┴─────┴─────┴─────┘

이제 동그라미가 4개! (짝수) ✓ 준비 완료!
```

**친구가 받아서 확인해요:**

```
친구가 받은 카드:
┌─────┬─────┬─────┬─────┬─────┐
│  1  │  0  │  1  │  1  │  1  │
└─────┴─────┴─────┴─────┴─────┘

친구: "동그라미 세어보자... 4개! 짝수네! ✓ 정상!"
```

**하지만 운송 중에 실수가 생기면?**

```
[1개만 실수로 바뀐 경우]

원본: 1 0 1 1 [1]
오류: 1 0 1 0 [1]  ← 세 번째 카드가 바뀜!
       ↑     ↑     ↑
     ● ○  ●     ●  = 3개 (홀수!)

친구: "음... 동그라미가 3개네? 홀수잖아! ✗ 오류 발견!"
     → "다시 보내줘!"
```

```
[2개가 실수로 바뀐 경우 - 문제 발생!]

원본: 1 0 1 1 [1]
오류: 0 0 1 0 [1]  ← 두 개가 바뀜!
       ↑     ↑     ↑
     ○ ○  ●     ●  = 2개 (짝수!)

친구: "동그라미가 2개... 짝수네? ✓ 정상?"
     → 하지만 실제로는 오류가 있었음! ✗
     → 이게 패리티 비트의 한계예요!
```

### 더 쉬운 비유: 학급 대표의 출석부 점검

**패리티 비트 = 출석부 맨 아래 "총원 확인란"**

```
[우리 반 출석부]

1번 김철수    ✓     (출석)
2번 이영희    ✓     (출석)
3번 박민수    ✗     (결석)
4번 최수진    ✓     (출석)
...
30번 임준영   ✓     (출석)
────────────────────
[총원 확인]   27명   ← 이게 패리티 비트!
```

**학급 반장이 확인하는 방법:**
1. 전부 세어보니 27명 출석
2. 맨 아래 "총원 확인"도 27명
3. 둘이 같으면 → ✓ 정상!
4. 다르면 → ✗ 어딘가 실수가 있어요!

**한계:**
- 한 명이 실수로 표시되어도 발견 ✓
- 두 명이 동시에 실수하면... 못 발견할 수도 ✗

이게 바로 **패리티 비트의 작동 원리와 한계**입니다!
