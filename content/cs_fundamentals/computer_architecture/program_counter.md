# 프로그램 카운터 (Program Counter, PC)

## 핵심 인사이트 (3줄 요약)
> CPU가 **다음에 실행할 명령어의 주소**를 저장하는 레지스터. 명령어 인출 후 자동 증가하며, 분기 명령어로 변경된다. 프로그램 흐름 제어의 핵심이다.

## 1. 개념
프로그램 카운터(PC)는 **다음에 실행할 명령어가 있는 메모리 주소**를 저장하는 특수 레지스터다. 명령어 포인터(IP)라고도 한다.

> 비유: "요리책 북마크" - 다음에 볼 페이지를 표시

## 2. PC 동작

```
명령어 실행 사이클:

1. PC 값으로 메모리에서 명령어 인출
2. PC 증가 (다음 명령어 주소)
3. 명령어 실행
4. 분기면 PC 변경, 아니면 그대로

예시:
PC=100 → 명령어 인출 → PC=104 → 실행
PC=104 → 명령어 인출 → PC=108 → 실행
```

## 3. PC 변경 상황

| 상황 | PC 변화 |
|------|---------|
| 순차 실행 | +4 (32비트 명령어) |
| 분기 (Branch) | 분기 주소로 변경 |
| 함수 호출 (Call) | 함수 시작 주소 |
| 인터럽트 | ISR 주소 |
| 리셋 | 리셋 벡터 |

## 4. 레지스터 파일에서의 위치

```
CPU 레지스터:

┌────────────────┐
│ R0 ~ R15       │  범용 레지스터
├────────────────┤
│ PC (R15)       │  프로그램 카운터
├────────────────┤
│ LR (R14)       │  링크 레지스터
├────────────────┤
│ SP (R13)       │  스택 포인터
├────────────────┤
│ CPSR           │  상태 레지스터
└────────────────┘
```

## 5. 분기와 PC

```
조건부 분기:

CMP R0, #0       ; R0과 0 비교
BEQ label        ; 같으면 label로 분기
ADD R1, R2, R3   ; 다르면 계속

분기 발생 시:
PC = label 주소

분기 미발생 시:
PC = 다음 명령어 주소
```

## 6. 함수 호출과 PC

```
함수 호출 과정:

BL func  ; Branch with Link
         ; LR = PC + 4 (다음 명령어)
         ; PC = func 주소

함수 내부:
PUSH {LR}  ; 반환 주소 저장
...        ; 함수 본문
POP {PC}   ; 반환 (PC = LR)
```

## 7. 파이프라인에서의 PC

```
5단계 파이프라인:

IF: PC로 명령어 인출
ID: 명령어 해석
EX: 실행
MEM: 메모리 접근
WB: 결과 저장

분기 시:
- 파이프라인 플러시
- PC 새로운 값으로 변경
→ 성능 저하 (분기 예측으로 완화)
```

## 8. 코드 예시

```c
// PC 흐름 시뮬레이션
int main() {
    int a = 1;      // PC: 0x100
    int b = 2;      // PC: 0x104
    int c = add(a, b); // PC: 0x108 → call → 0x200
    return c;       // PC: 0x10C
}

int add(int x, int y) {  // PC: 0x200
    return x + y;        // PC: 0x204 → ret → 0x10C
}
```

## 9. 장단점

| 장점 | 단점 |
|-----|------|
| 간단한 구현 | 분기 예측 어려움 |
| 순차 실행 최적 | 파이프라인 플러시 비용 |

## 10. 실무에선? (기술사적 판단)
- **분기 예측**: PC 기반으로 다음 주소 예측
- **BTB**: Branch Target Buffer로 분기 주소 캐시
- **보안**: PC 하이재킹 방지 (DEP, ASLR)

## 11. 관련 개념
- 명령어 레지스터 (IR)
- 링크 레지스터 (LR)
- 분기 예측

---

## 어린이를 위한 종합 설명

**프로그램 카운터는 "요리책 북마크"야!**

요리할 때 어디까지 했는지 기억하죠?

```
PC = "지금 5페이지 보는 중"

5페이지 완료 → PC = 6페이지로!
6페이지 완료 → PC = 7페이지로!
```

### 분기 (다른 페이지로 점프)
```
"버터가 없으면 20페이지 대체 레시피로!"

PC = 7페이지 → "버터 없음!" → PC = 20페이지
```

### 함수 호출 (다른 요리법 보러 가기)
```
"파스타 소스 만드는 법은 50페이지 참조"

PC = 현재 페이지
→ 50페이지로 이동 (소스 만들기)
→ 다시 돌아오기
```

**비밀**: PC는 컴퓨터가 "다음엔 뭐 해야 하지?"를 기억하는 방법이에요! 📖
