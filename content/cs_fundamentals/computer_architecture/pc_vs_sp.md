+++
title = "PC vs SP 비교"
date = 2025-03-01
+++

# 프로그램 카운터 vs 스택 포인터 (PC vs SP)

## 핵심 인사이트 (3줄 요약)
> **PC**는 "다음에 **실행할 명령어**가 어디 있나?"를, **SP**는 "다음에 **저장할 데이터**를 어디에 둘까?"를 관리한다. PC는 **코드 영역**을, SP는 **스택 영역**을 가리킨다. 둘 다 주소를 저장하지만 목적과 동작 방식이 완전히 다르다.

---

## 1. 한눈에 보는 핵심 차이

| 구분 | PC (Program Counter) | SP (Stack Pointer) |
|------|---------------------|-------------------|
| **질문** | "다음에 무엇을 실행할까?" | "데이터를 어디에 저장할까?" |
| **가리키는 것** | **명령어** 주소 | **데이터** 주소 (스택 최상단) |
| **메모리 영역** | 코드(Code/Text) 영역 | 스택(Stack) 영역 |
| **주요 용도** | 프로그램 흐름 제어 | 함수 호출/지역변수 관리 |
| **동작 방식** | 순차 증가 + 분기 시 변경 | PUSH↓ / POP↑ |
| **방향** | 주로 증가 (앞으로) | 주로 감소 (아래로) |
| **대응 개념** | 요리책 북마크 📖 | 접시 탑의 꼭대기 🍽️ |

---

## 2. 개념적 차이

### PC (Program Counter)
```
"요리책에서 다음에 볼 페이지"

┌─────────────────┐
│  메모리 (코드)   │
├─────────────────┤
│ 0x100: MOV R1, 1│ ← PC가 여기 가리킴
│ 0x104: MOV R2, 2│    "이거 실행해!"
│ 0x108: ADD R1, R2│
│ 0x10C: ...      │
└─────────────────┘
```

### SP (Stack Pointer)
```
"접시 쌓기에서 맨 위 접시 위치"

         ↓ 스택은 아래로 자람
┌─────────────────┐
│     ...         │
├─────────────────┤
│   지역변수 B    │
├─────────────────┤
│   지역변수 A    │ ← SP가 여기 가리킴
└─────────────────┘    "여기가 끝이야!"
```

---

## 3. 동작 시점 비교

### PC 동작 (명령어 사이클)
```
1. PC 값으로 명령어 인출 (Fetch)
2. PC 증가 (다음 명령어 준비)
3. 명령어 실행
4. 분기면 PC 변경, 아니면 그대로

반복!
```

### SP 동작 (함수 호출 시)
```
함수 진입:
1. 반환 주소 PUSH → SP 감소
2. 지역변수 공간 확보 → SP 감소

함수 종료:
1. 지역변수 공간 해제 → SP 증가
2. 반환 주소 POP → SP 증가
```

---

## 4. 실제 동작 예시

```c
void main() {          // PC=0x100
    int a = 1;         // PC=0x104
    func(10);          // PC=0x108 → 분기!
}

void func(int x) {     // PC=0x200 (함수 시작)
    int b = x + 1;     // PC=0x204
}                      // PC=0x208 → 복귀!
```

### 이때 SP와 PC의 변화

```
main() 실행 중:
┌──────────────────────────────────────┐
│ PC = 0x108 (func 호출 직전)          │
│ SP = 0x7FF0 (메인의 스택 사용 중)     │
└──────────────────────────────────────┘
              ↓ CALL func
┌──────────────────────────────────────┐
│ PC = 0x200 (func 시작)               │
│ SP = 0x7FE0 (반환주소 + 지역변수)     │ ← SP 감소!
└──────────────────────────────────────┘
              ↓ RET (func 종료)
┌──────────────────────────────────────┐
│ PC = 0x10C (main으로 복귀)           │
│ SP = 0x7FF0 (원래대로 복구)          │ ← SP 증가!
└──────────────────────────────────────┘
```

---

## 5. 왜 따로 관리할까?

```
┌─────────────────────────────────────────────────────┐
│                    메모리 맵                         │
├─────────────────────────────────────────────────────┤
│ 0x0000  ┌─────────────┐                             │
│         │   코드      │ ← PC가 관리                 │
│         │  (명령어)   │    "무엇을 실행할지"         │
│         ├─────────────┤                             │
│         │   데이터    │                             │
│         ├─────────────┤                             │
│         │    힙       │                             │
│         │      ↓      │                             │
│         │      ...    │                             │
│         │      ↑      │                             │
│         │   스택      │ ← SP가 관리                 │
│ 0xFFFF  └─────────────┘    "데이터를 어디에"         │
└─────────────────────────────────────────────────────┘

→ 코드와 스택은 독립적으로 성장!
→ PC와 SP가 따로 관리되어야 유연한 실행 가능
```

---

## 6. 혼동하기 쉬운 점

| 오해 | 진실 |
|------|------|
| "둘 다 주소니까 비슷하다" | 목적이 완전히 다름 (명령어 vs 데이터) |
| "SP도 명령어를 가리킨다" | SP는 데이터(변수, 반환주소)만 관리 |
| "PC는 항상 증가한다" | 분기/호출/인터럽트 시 변경됨 |
| "SP는 항상 감소한다" | POP/함수복귀 시 증가 |

---

## 7. 기술사 시험 포인트

### 암기 팁
```
PC = Program Counter = 명령어 위치 = 코드 쪽
SP = Stack Pointer = 데이터 위치 = 스택 쪽

P → Program → 명령어
S → Stack → 데이터
```

### 시험에서 물어볼 수 있는 것
1. **PC와 SP의 차이점** (본 항목)
2. **함수 호출 시 두 레지스터의 변화**
3. **인터럽트 발생 시 PC와 SP의 동작**
4. **파이프라인에서 PC의 역할** (분기 예측)
5. **스택 오버플로우와 SP의 관계**

---

## 8. 관련 레지스터와의 관계

```
함수 호출 시 3대 레지스터 동작:

PC: "다음 명령어 어디?" → 함수 주소로 변경
LR: "돌아올 곳 어디?" → 호출한 곳 다음 주소 저장
SP: "스택 어디까지?" → 반환주소 저장하고 내려감

CALL func 시:
  LR = PC + 4  (돌아올 주소)
  PUSH LR      (스택에 저장 → SP 감소)
  PC = func    (함수로 이동)

RET 시:
  POP PC       (스택에서 반환주소 꺼내 → SP 증가)
  PC = LR      (원래 위치로 복귀)
```

---

## 어린이를 위한 종합 설명

### PC와 SP는 "요리사의 두 가지 도구"

```
PC = 요리책 북마크 📖
"다음에 어떤 요리법을 볼까?"

SP = 접시 탑의 꼭대기 표시 🍽️
"접시를 어디까지 쌓았지?"
```

### 요리 비유

```
요리하는데 전화가 왔어요!

[PC의 역할]
1. 요리책 5페이지 보는 중 (PC = 5페이지)
2. 전화 받으러 50페이지로 이동! (PC = 50페이지)
3. 전화 끝나면 다시 5페이지로 (PC = 5페이지)

→ "다음에 뭘 할지"를 기억!

[SP의 역할]
1. 하던 요리 재료를 접시에 담아둠 (SP = 접시1)
2. 전화 받을 때 더 중요한 걸 위에 쌓음 (SP = 접시2)
3. 전화 끝나면 위에 것부터 꺼냄 (SP = 접시1)

→ "중간에 멈춘 것"을 기억!
```

### 핵심 차이 한 줄
```
PC: "다음에 뭘 할까?" → 실행할 명령어
SP: "중간에 뭘 저장했지?" → 잠시 멈춘 데이터
```

**비밀**: PC는 "미래"를, SP는 "과거"를 기억해요! 🎯
