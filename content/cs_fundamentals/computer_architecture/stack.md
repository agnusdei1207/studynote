# 스택 (Stack)

## 핵심 인사이트 (3줄 요약)
> **후입선출(LIFO)** 구조의 자료구조. 함수 호출, 지역 변수, 인터럽트 처리에 사용되는 핵심 메모리 영역이다. PUSH/POP 연산으로 데이터를 저장하고 꺼낸다.

## 1. 개념
스택(Stack)은 **가장 나중에 넣은 데이터를 가장 먼저 꺼내는(LIFO)** 자료구조다. 메모리 영역으로서 함수 호출 관리에 필수적이다.

> 비유: "접시 쌓기" - 맨 위에 쌓고, 맨 위에서 꺼냄

## 2. 스택 구조

```
       ┌───────┐
       │   D   │ ← SP (Stack Pointer)
       ├───────┤
       │   C   │
       ├───────┤
       │   B   │
       ├───────┤
       │   A   │
       └───────┘

LIFO: Last In, First Out
나중에 들어간 게 먼저 나옴
```

## 3. 기본 연산

```
PUSH: 데이터 넣기
      SP 감소 → 데이터 저장

POP:  데이터 꺼내기
      데이터 읽기 → SP 증가

┌───────┐         ┌───────┐
│   D   │ PUSH E  │   E   │ ← SP
├───────┤   →     ├───────┤
│   C   │         │   D   │
└───────┘         └───────┘
```

## 4. 스택 포인터 (SP)

```
스택 포인터 역할:
- 스택 최상단(Top)을 가리킴
- PUSH 시 감소 (Full Descending)
- POP 시 증가

ARM Cortex-M: SP는 R13 레지스터
x86: SP (16-bit) 또는 ESP (32-bit)
```

## 5. 스택 활용

| 용도 | 설명 |
|------|------|
| 함수 호출 | 반환 주소 저장 |
| 지역 변수 | 함수 내 변수 저장 |
| 매개변수 | 함수 인자 전달 |
| 인터럽트 | 레지스터 저장 |
| 수식 계산 | 후위 표기법 |

## 6. 함수 호출과 스택

```
void funcA() {
    funcB();  // 호출
    // ...
}

void funcB() {
    int x = 10;  // 지역 변수
    // ...
}

스택 변화:
┌────────────────┐
│ funcA의 지역변수│
├────────────────┤
│ funcA 반환주소  │
├────────────────┤
│ funcB의 지역변수│ ← SP
└────────────────┘

funcB 종료 시:
- 지역 변수 제거
- 반환 주소로 복귀
```

## 7. 스택 프레임

```
┌────────────────┐
│    매개변수     │
├────────────────┤
│   반환 주소     │
├────────────────┤ ← 이전 FP
│   이전 FP      │
├────────────────┤
│   지역 변수    │
├────────────────┤
│   임시 공간    │ ← SP
└────────────────┘

FP (Frame Pointer): 현재 프레임 시작점
SP (Stack Pointer): 현재 프레임 끝점
```

## 8. 스택 오버플로우

```
스택 오버플로우 원인:
1. 무한 재귀 호출
2. 너무 큰 지역 변수
3. 너무 깊은 함수 호출

해결:
1. 재귀 → 반복문
2. 동적 할당 사용
3. 스택 크기 증가
```

## 9. 코드 예시

```c
// 함수 호출 스택
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);  // 재귀 호출
}

factorial(3):
┌──────────────┐
│ n=3, ret=?   │
├──────────────┤
│ n=2, ret=?   │
├──────────────┤
│ n=1, ret=1   │ ← 베이스 케이스
└──────────────┘
```

```python
# Python 리스트로 스택 구현
stack = []

stack.append(1)  # PUSH
stack.append(2)
stack.append(3)

print(stack.pop())  # 3 (POP)
print(stack.pop())  # 2
```

## 10. 장단점

| 장점 | 단점 |
|-----|------|
| 구현 간단 | 중간 접근 불가 |
| 메모리 관리 쉬움 | 크기 제한 |
| 함수 호출에 최적 | 오버플로우 위험 |

## 11. 실무에선? (기술사적 판단)
- **임베디드**: 스택 크기 신중히 설정
- **RTOS**: 각 태스크마다 스택 할당
- **보안**: 스택 카나리, ASLR로 보호
- **디버깅**: 스택 트레이스로 호출 추적

## 12. 관련 개념
- 힙 (Heap)
- 스택 포인터
- 재귀 호출

---

## 어린이를 위한 종합 설명

**스택은 "접시 탑"이야!**

### 접시 쌓기 (PUSH)
```
접시를 차곡차곡 쌓아요:

      ┌───┐
      │ 3 │ ← 맨 위
      ├───┤
      │ 2 │
      ├───┤
      │ 1 │
      └───┘
```

### 접시 꺼내기 (POP)
```
맨 위에서부터 꺼내요:

      ┌───┐
      │ 3 │ ← 이거 먼저! (LIFO)
      └───┘
```

### 함수 호출 비유
```
일하는 중에 전화가 왔어요:

1. 하던 일 저장 (스택에 PUSH)
2. 전화 받음
3. 전화 중에 또 전화!
4. 하던 일(전화) 저장 (PUSH)
5. 새 전화 받음
6. 끝나면 복귀 (POP)

→ 나중에 시작한 일이 먼저 끝나요!
```

**비밀**: 컴퓨터가 "어디까지 했더라?"를 기억하는 방법이에요! 📚
