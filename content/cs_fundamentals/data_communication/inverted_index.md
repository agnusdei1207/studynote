+++
title = "역색인(Inverted Index)이란? — 검색 엔진의 핵심 구조"
date = 2026-02-28

[extra]
categories = "cs_fundamentals-data_communication"
+++

# 역색인(Inverted Index)이란? — 검색 엔진의 핵심 구조

## 한 줄 정의

> **"단어가 어느 문서에 있는지"를 미리 정리해둔 표.** 구글, Pagefind 모두 이걸 쓴다.

---

## 1. 문제: 검색하려면 뭘 해야 할까?

문서가 3개 있다:

```
문서 A: "Rust는 빠르고 안전하다"
문서 B: "Python은 쉽고 느리다"
문서 C: "Rust는 메모리를 직접 관리한다"
```

사용자가 **"Rust"** 를 검색하면 어떻게 찾을까?

### 방법 1 (나쁜 방법): 전부 다 읽기

```
"Rust" 찾기
→ 문서 A 처음부터 끝까지 읽음... 있음!
→ 문서 B 처음부터 끝까지 읽음... 없음
→ 문서 C 처음부터 끝까지 읽음... 있음!
→ 결과: A, C
```

문서가 10만 개면? **10만 개를 전부 읽는다** → 수십 초 걸림.

### 방법 2 (좋은 방법): 미리 표를 만들어두기

검색하기 **전에** 미리 이런 표를 만들어둔다:

```
"Rust"   → [문서 A, 문서 C]
"Python" → [문서 B]
"빠르고" → [문서 A]
"느리다" → [문서 B]
"안전"   → [문서 A]
"메모리" → [문서 C]
```

이제 "Rust" 검색하면:  
표에서 "Rust" 항목만 보면 된다 → **즉시** [문서 A, 문서 C] 반환.

**이 표가 바로 역색인(Inverted Index)이다.**

---

## 2. 왜 "역(逆)색인"인가?

일반 색인(Index)과 역색인을 비교해보자.

### 일반 색인 (목차 방식)

**문서가 키, 단어들이 값**:

```
문서 A → [Rust, 빠르다, 안전하다]
문서 B → [Python, 쉽다, 느리다]
문서 C → [Rust, 메모리, 관리]
```

→ "문서 A에 뭐가 있나?" 는 빠르게 알 수 있음
→ **"Rust가 어느 문서에 있나?" 는 여전히 전부 뒤져야 함** ❌

### 역색인 (뒤집은 방식)

**단어가 키, 문서들이 값** — 키와 값의 위치를 뒤집음:

```
Rust    → [문서 A, 문서 C]
Python  → [문서 B]
빠르다  → [문서 A]
느리다  → [문서 B]
안전하다 → [문서 A]
메모리  → [문서 C]
```

→ "Rust가 어느 문서에 있나?" 즉시 답 가능 ✅

**"역"인 이유: 원래 색인과 키·값이 뒤바뀌어 있기 때문.**

---

## 3. 실제로 어떻게 만드나?

### 3단계 과정

**1단계: 문서에서 단어 추출 (토크나이징)**

```
문서 A: "Rust는 빠르고 안전하다"
→ 단어 목록: [Rust, 빠르다, 안전하다]
```

**2단계: 위치 기록**

```
단어 "Rust"  → 문서 A 1번째 단어, 문서 C 1번째 단어
단어 "빠르다" → 문서 A 2번째 단어
```

**3단계: 표로 정리**

```
"Rust"    → {문서 A: 위치 1, 문서 C: 위치 1}
"빠르다"  → {문서 A: 위치 2}
"안전하다" → {문서 A: 위치 3}
```

---

## 4. Pagefind는 역색인을 어떻게 쓰나?

Pagefind는 역색인을 **알파벳/음절별로 잘라서** 파일로 저장한다.

```
index_r.pf_index  ← "r"로 시작하는 단어들의 역색인
  rust  → [문서 B, 문서 D]
  rayon → [문서 E]

index_n.pf_index  ← "n"으로 시작하는 단어들의 역색인
  network → [문서 A, 문서 C]
  node    → [문서 F]
```

사용자가 **"rust"** 검색 → `index_r` 파일 1개만 가져옴 (~10KB)
→ 표에서 "rust" 항목 즉시 조회
→ [문서 B, 문서 D] 반환

**글이 10만 개여도 `index_r` 파일 크기는 그대로 → 메모리 항상 일정.**

---

## 5. lunr.js와 비교

| | lunr.js | Pagefind |
|---|---|---|
| **저장 방식** | 역색인 전체를 하나의 파일로 | 역색인을 알파벳별 파일로 분할 |
| **검색 시 로드** | 전체 파일 한 번에 메모리에 올림 | 필요한 파일 1개만 가져옴 |
| **글 1,000개** | 5MB 메모리 | 5~10KB 메모리 |
| **글 10만 개** | 수백 MB → 브라우저 먹통 | 여전히 5~10KB |

역색인이라는 아이디어는 같지만, **파일을 쪼개冰느냐 마느냐**가 결정적 차이다.

---

## 6. 구글도 역색인을 쓴다

구글의 검색 엔진도 동일한 원리다:

```
수십억 웹 페이지를 크롤링
    ↓
각 페이지에서 단어 추출
    ↓
단어 → [페이지 목록] 역색인 구축
    ↓
"rust programming" 검색
    ↓
역색인에서 "rust" 목록 + "programming" 목록 교집합
    ↓
결과 페이지 순위 정렬
```

차이는 규모뿐이다. 구글은 이 역색인이 수천 대 서버에 분산 저장되어 있다.

---

## 7. 한 줄 요약

> **역색인 = 도서관 색인 카드.**
> 단어별로 "이 단어는 몇 번 책, 몇 쪽에 있다"를 미리 적어두면, 책을 전부 셃을 필요 없이 카드만 보면 된다.
> Pagefind는 이 카드를 ㄱ/ㄴ/ㄷ 서랍으로 나눠서, 해당 서랍 하나만 열어보게 만든 것이다.
